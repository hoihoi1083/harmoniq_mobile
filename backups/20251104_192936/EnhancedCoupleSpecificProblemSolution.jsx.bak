"use client";

import React, { useState, useEffect, useMemo } from "react";
import { useSession } from "next-auth/react";
import { useTranslations } from "next-intl";
import Image from "next/image";
import { Heart, Users, Target } from "lucide-react";
import { calculateUnifiedElements } from "@/lib/unifiedElementCalculation";
import { useCoupleAnalysis } from "@/contexts/CoupleAnalysisContext";
import {
	saveComponentContentWithUser,
	getSavedContent,
} from "@/utils/simpleCoupleContentSave";
import { getCoupleComponentData } from "@/utils/coupleComponentDataStore";
import ChartDiagnosisSection from "./ChartDiagnosisSection";
import EmergencyFengShuiSection from "./EmergencyFengShuiSection";
import RestartChemistrySection from "./RestartChemistrySection";
import StarChartGuidanceSection from "./StarChartGuidanceSection";
import FengShuiTransformationSection from "./FengShuiTransformationSection";
import RelationshipMethodSection from "./RelationshipMethodSection";
import KeyAnalysisSection from "./KeyAnalysisSection";
import TargetedSuggestionsSection from "./TargetedSuggestionsSection";

const EnhancedCoupleSpecificProblemSolution = ({
	user1,
	user2,
	specificProblem,
	isSimplified = false,
}) => {
	const t = useTranslations(
		"coupleReport.enhancedCoupleSpecificProblemSolution"
	);
	const { data: session } = useSession();
	const { analysisData: contextAnalysisData } = useCoupleAnalysis();
	const [analysisData, setAnalysisData] = useState(null);
	const [loading, setLoading] = useState(false);
	const [problemCategory, setProblemCategory] = useState(null);
	const [subsectionData, setSubsectionData] = useState({});
	const [databaseDataLoaded, setDatabaseDataLoaded] = useState(false);

	// Extract birth information from users
	const femaleUser = user1?.gender === "female" ? user1 : user2;
	const maleUser = user1?.gender === "male" ? user1 : user2;

	// Calculate compatibility score based on BaZi elements (same logic as CoupleAnnualAnalysis)
	const calculateBasicCompatibilityScore = (analysis1, analysis2) => {
		if (!analysis1?.dayMasterElement || !analysis2?.dayMasterElement) {
			return 75; // Default score if elements can't be calculated
		}

		const element1 = analysis1.dayMasterElement;
		const element2 = analysis2.dayMasterElement;

		const compatibilityMatrix = {
			Èáë: { Èáë: 70, Êú®: 40, Ê∞¥: 85, ÁÅ´: 35, Âúü: 80 },
			Êú®: { Èáë: 40, Êú®: 75, Ê∞¥: 80, ÁÅ´: 85, Âúü: 45 },
			Ê∞¥: { Èáë: 85, Êú®: 80, Ê∞¥: 70, ÁÅ´: 30, Âúü: 50 },
			ÁÅ´: { Èáë: 35, Êú®: 85, Ê∞¥: 30, ÁÅ´: 75, Âúü: 80 },
			Âúü: { Èáë: 80, Êú®: 45, Ê∞¥: 50, ÁÅ´: 80, Âúü: 70 },
		};

		return compatibilityMatrix[element1]?.[element2] || 60;
	};

	const getCompatibilityLevel = (score) => {
		if (score >= 80) return t("compatibilityLevels.excellent");
		if (score >= 70) return t("compatibilityLevels.good");
		if (score >= 60) return t("compatibilityLevels.stable");
		return t("compatibilityLevels.needsWork");
	};

	// Function to handle subsection data collection
	const handleSubsectionData = (sectionName, data) => {
		console.log(`üìä Received data from ${sectionName}:`, !!data);
		setSubsectionData((prev) => ({
			...prev,
			[sectionName]: data,
		}));
	};

	// Function to save complete data including all subsections
	const saveCompleteAnalysisData = (baseData, subsections) => {
		const sessionId =
			`couple_${user1.birthDateTime}_${user2.birthDateTime}`.replace(
				/[^a-zA-Z0-9]/g,
				"_"
			);

		const completeData = {
			...baseData,
			subsections: subsections,
			completedAt: new Date().toISOString(),
		};

		console.log(
			"üíæ Saving complete EnhancedCoupleSpecificProblemSolution data:",
			{
				baseData: !!baseData,
				subsectionsCount: Object.keys(subsections).length,
				subsections: Object.keys(subsections),
			}
		);

		saveComponentContentWithUser(
			session,
			sessionId,
			"enhancedCoupleSpecificProblemSolution",
			completeData,
			{
				birthday: user1.birthDateTime,
				birthday2: user2.birthDateTime,
				gender: user1.gender,
				gender2: user2.gender,
				specificProblem: specificProblem,
				problemCategory: problemCategory,
			}
		);
	};

	// Effect to save complete data when all subsections are ready
	useEffect(() => {
		if (analysisData && Object.keys(subsectionData).length > 0) {
			console.log(
				"üîÑ Checking if all expected subsections are ready...",
				{
					analysisData: !!analysisData,
					subsectionsCount: Object.keys(subsectionData).length,
					subsectionKeys: Object.keys(subsectionData),
				}
			);

			// Save complete data (we'll collect subsections as they become available)
			const timeoutId = setTimeout(() => {
				saveCompleteAnalysisData(analysisData, subsectionData);
			}, 2000); // Wait 2 seconds to collect more subsections

			return () => clearTimeout(timeoutId);
		}
	}, [
		analysisData,
		subsectionData,
		user1.birthDateTime,
		user2.birthDateTime,
		specificProblem,
	]);

	// ÔøΩ STABLE compatibility score with robust synchronization
	const [stableScore, setStableScore] = useState(null);
	const [contextDataStable, setContextDataStable] = useState(false);

	// Enhanced synchronization with context data stability detection
	const compatibilityScore = useMemo(() => {
		console.log(
			"üîÑ EnhancedCoupleSpecificProblemSolution - Calculating compatibility score",
			{
				hasContextData: !!contextAnalysisData,
				contextScore: contextAnalysisData?.compatibility?.score,
				contextDataStable,
				currentStableScore: stableScore,
				femaleUser: !!femaleUser,
				maleUser: !!maleUser,
			}
		);

		// PRIORITY 0: If we already have a stable score, use it to prevent changes
		if (stableScore !== null) {
			console.log(
				"üîí EnhancedCoupleSpecificProblemSolution - Using LOCKED stable score:",
				stableScore
			);
			return stableScore;
		}

		// PRIORITY 1: Wait for context data to stabilize before using it
		if (contextAnalysisData?.compatibility?.score && contextDataStable) {
			const calculatedScore = parseInt(
				contextAnalysisData.compatibility.score
			);
			console.log(
				"‚úÖ EnhancedCoupleSpecificProblemSolution - Using STABLE context score (SYNCHRONIZED):",
				{
					rawScore: contextAnalysisData.compatibility.score,
					parsedScore: calculatedScore,
					contextDataStable,
					timestamp: new Date().toISOString(),
				}
			);
			return calculatedScore;
		}

		// PRIORITY 2: Still waiting for context data to stabilize
		if (contextAnalysisData === null || !contextDataStable) {
			console.log(
				"‚è≥ EnhancedCoupleSpecificProblemSolution - Waiting for STABLE context data, using temporary score"
			);
			return 75; // Temporary while waiting for stable data
		}

		// PRIORITY 3: Context data is stable but no score - calculate locally
		if (femaleUser?.birthDateTime && maleUser?.birthDateTime) {
			try {
				const user1Analysis = calculateUnifiedElements(
					femaleUser.birthDateTime,
					femaleUser.gender
				);
				const user2Analysis = calculateUnifiedElements(
					maleUser.birthDateTime,
					maleUser.gender
				);

				const calculatedScore = calculateBasicCompatibilityScore(
					user1Analysis,
					user2Analysis
				);

				console.log(
					"‚ö†Ô∏è EnhancedCoupleSpecificProblemSolution - Using calculated score (FALLBACK):",
					calculatedScore
				);
				return calculatedScore;
			} catch (error) {
				console.error("Error calculating compatibility:", error);
				return 75; // Default fallback
			}
		}

		// Ultimate fallback
		console.log(
			"‚ùå EnhancedCoupleSpecificProblemSolution - Using ultimate fallback score"
		);
		return 75;
	}, [
		femaleUser,
		maleUser,
		contextAnalysisData,
		contextDataStable,
		stableScore,
	]);

	// Detect when context data has stabilized (check immediately and on updates)
	useEffect(() => {
		if (contextAnalysisData?.compatibility?.score && !contextDataStable) {
			// Check if data is immediately available (synchronous case)
			if (contextAnalysisData.compatibility.score) {
				console.log(
					"üìä EnhancedCoupleSpecificProblemSolution - Context data IMMEDIATELY stable"
				);
				setContextDataStable(true);
				return;
			}

			// Fallback minimal delay for edge cases
			const stabilityTimer = setTimeout(() => {
				console.log(
					"üìä EnhancedCoupleSpecificProblemSolution - Context data marked as STABLE (delayed)"
				);
				setContextDataStable(true);
			}, 50); // Minimal 50ms delay for edge cases

			return () => clearTimeout(stabilityTimer);
		}
	}, [contextAnalysisData, contextDataStable]);

	// Lock the score only when we have stable context data
	useEffect(() => {
		if (
			stableScore === null &&
			contextDataStable &&
			contextAnalysisData?.compatibility?.score &&
			compatibilityScore !== 75 // Don't lock temporary scores
		) {
			console.log(
				"üîí EnhancedCoupleSpecificProblemSolution - LOCKING STABLE score to prevent changes:",
				compatibilityScore
			);
			setStableScore(compatibilityScore);
		}
	}, [
		compatibilityScore,
		stableScore,
		contextAnalysisData,
		contextDataStable,
	]);

	// Format birth date for display
	const formatBirthDate = (birthDateTime) => {
		if (!birthDateTime) return "Êú™Êèê‰æõ";
		try {
			const date = new Date(birthDateTime);
			return `${date.getFullYear()}Âπ¥${String(date.getMonth() + 1).padStart(2, "0")}Êúà${String(date.getDate()).padStart(2, "0")}Êó•${String(date.getHours()).padStart(2, "0")}:${String(date.getMinutes()).padStart(2, "0")}`;
		} catch (error) {
			return birthDateTime;
		}
	};

	// Format BaZi description with structured content
	const formatBaziDescription = (rawDescription) => {
		if (!rawDescription) return t("baziAnalysisGenerating");

		// If content is too long (over 300 characters), extract key points
		if (rawDescription.length > 300) {
			// Try to extract structured sections
			const sections = rawDescription.split(/[**]|[###]|[\n]{2,}/);
			const keyPoints = [];

			// Look for key analysis patterns
			const patterns = [
				/Êó•‰∏ªÂàÜÊûê[Ôºö:](.{1,120})/,
				/ÂçÅÁ•ûÁâπË≥™[Ôºö:](.{1,120})/,
				/ÈóúÈçµÁüõÁõæ[Ôºö:](.{1,120})/,
				/ÊÄßÊ†ºÁâπÊÄß[Ôºö:](.{1,120})/,
				/‰∏ªË¶ÅÂÑ™Âã¢[Ôºö:](.{1,120})/,
				/Ê†∏ÂøÉÁâπË≥™(.{1,120})/,
			];

			for (const pattern of patterns) {
				const match = rawDescription.match(pattern);
				if (match && match[1]) {
					keyPoints.push(match[1].trim().replace(/[*#]/g, ""));
					if (keyPoints.length >= 2) break; // Limit to 2 key points
				}
			}

			// If we found structured content, use it
			if (keyPoints.length > 0) {
				return keyPoints.join(" ");
			}

			// Otherwise, truncate intelligently
			const sentences = rawDescription.split(/[„ÄÇÔºÅÔºü]/);
			let result = "";
			for (const sentence of sentences) {
				if (result.length + sentence.length < 200) {
					result += sentence + "„ÄÇ";
				} else {
					break;
				}
			}
			return result || rawDescription.substring(0, 180) + "...";
		}

		// For shorter content, clean up formatting
		return rawDescription.replace(/[*#]/g, "").trim();
	};

	// Categorize problem when specificProblem changes
	useEffect(() => {
		if (specificProblem) {
			const category = categorizeLocalProblem(specificProblem);
			setProblemCategory(category);
		}
	}, [specificProblem]);

	// Load saved data from database first (highest priority) - TEMPORARILY DISABLED TO TEST NEW BILINGUAL FALLBACK
	useEffect(() => {
		console.log(
			"üêõ DEBUG: useEffect triggered - user1:",
			user1,
			"user2:",
			user2
		);
		console.log("üêõ DEBUG: femaleUser:", femaleUser, "maleUser:", maleUser);

		if (user1 && user2) {
			// TEMPORARILY SKIP DATABASE LOADING TO TEST NEW FALLBACK LOGIC
			console.log(
				"‚è≠Ô∏è SKIPPING database load to test new bilingual fallback"
			);
			setDatabaseDataLoaded(true);
		}
	}, [user1.birthDateTime, user2.birthDateTime]);

	/* COMMENTED OUT FOR TESTING - RE-ENABLE AFTER VERIFYING FIX
	// Original database loading code:
	useEffect(() => {
		if (user1 && user2) {
			const loadSavedData = async () => {
				const sessionId =
					`couple_${user1.birthDateTime}_${user2.birthDateTime}`.replace(
						/[^a-zA-Z0-9]/g,
						"_"
					);

				try {
					console.log(
						"üîç Loading EnhancedCoupleSpecificProblemSolution data from database for session:",
						sessionId
					);
					const result = await getSavedContent(sessionId);

					if (
						result.success &&
						result.savedContent &&
						result.savedContent
							.enhancedCoupleSpecificProblemSolution
					) {
						console.log(
							"üèõÔ∏è Found saved EnhancedCoupleSpecificProblemSolution data in database:",
							result.savedContent
								.enhancedCoupleSpecificProblemSolution
						);
						const savedData =
							result.savedContent
								.enhancedCoupleSpecificProblemSolution;

						setAnalysisData(savedData);
						setDatabaseDataLoaded(true);
						setLoading(false);

						// Also set subsection data if available
						if (savedData.subsections) {
							setSubsectionData(savedData.subsections);
						}

						// Set problem category from saved metadata if available
						if (
							result.metadata &&
							result.metadata.problemCategory
						) {
							setProblemCategory(result.metadata.problemCategory);
						}

						return;
					} else {
						console.log(
							"üîç No saved EnhancedCoupleSpecificProblemSolution data found in database",
							result
						);
					}
				} catch (error) {
					console.error(
						"‚ùå Error loading saved EnhancedCoupleSpecificProblemSolution data:",
						error
					);
				}

				// Mark as loaded even if no data found, so fresh generation can proceed
				setDatabaseDataLoaded(true);
			};

			loadSavedData();
		}
	}, [user1.birthDateTime, user2.birthDateTime]);
	*/

	// Generate couple analysis when component mounts or data changes (fallback)
	useEffect(() => {
		// Skip if database data was already loaded
		if (databaseDataLoaded) return;

		if (femaleUser && maleUser && specificProblem) {
			// Check for historical data from browser storage (fallback)
			const historicalData = getCoupleComponentData(
				"enhancedCoupleSpecificProblemSolution"
			);
			if (historicalData) {
				console.log(
					"üìö Loading historical data from browser storage for Enhanced Couple Specific Problem Solution"
				);
				setAnalysisData(historicalData);
				setLoading(false);
			} else {
				generateCoupleAnalysis();
			}
		}
	}, [femaleUser, maleUser, specificProblem, databaseDataLoaded]);

	// Local problem categorization function
	const categorizeLocalProblem = (problem) => {
		if (!problem) return null;

		const problemLower = problem.toLowerCase();
		console.log("üîç Categorizing problem:", problem);
		console.log("üîç Problem lowercase:", problemLower);

		// ÊÑüÊÉÖÈôçÊ∫´È°û keywords
		if (
			problemLower.includes("ÂÜ∑Êà∞") ||
			problemLower.includes("ÈôçÊ∫´") ||
			problemLower.includes("ÁñèÈÅ†") ||
			problemLower.includes("ÂÜ∑Ê∑°") ||
			problemLower.includes("ÊÑüÊÉÖÊ∑°") ||
			problemLower.includes("‰∏çÁêÜÊàë")
		) {
			return {
				category: "emotion_cooling",
				categoryKey: "emotionCooling",
				color: "bg-pink-100 border-pink-300 text-pink-800",
				icon: "Heart",
			};
		}

		// ÁâπÊÆäÊÉÖÂ¢ÉÈ°û keywords
		if (
			problemLower.includes("Áï∞Âú∞") ||
			problemLower.includes("Èï∑Ë∑ùÈõ¢") ||
			problemLower.includes("Â∑•‰Ωú") ||
			problemLower.includes("ÂÆ∂Â∫≠") ||
			problemLower.includes("Áà∂ÊØç") ||
			(problemLower.includes("ÊúãÂèã") &&
				!problemLower.includes("Áî∑ÊúãÂèã") &&
				!problemLower.includes("Â•≥ÊúãÂèã")) ||
			problemLower.includes("Áí∞Â¢É") ||
			problemLower.includes("Â£ìÂäõ")
		) {
			console.log("üìç Matched ÁâπÊÆäÊÉÖÂ¢ÉÈ°û");
			return {
				category: "special_situation",
				categoryKey: "specialSituation",
				color: "bg-blue-100 border-blue-300 text-blue-800",
				icon: "Globe",
			};
		}

		// Á¶ÅÂøåÁ†¥Ëß£Ë©±Ë°ì keywords
		if (
			problemLower.includes("Ë™™ÈåØË©±") ||
			problemLower.includes("Ë©±Ë°ì") ||
			problemLower.includes("Ê∫ùÈÄö") ||
			problemLower.includes("Ë™§ÊúÉ") ||
			problemLower.includes("Áà≠Âêµ") ||
			problemLower.includes("Âè£Ëßí") ||
			problemLower.includes("ÂêµÊû∂") ||
			problemLower.includes("Á¶ÅÂøå")
		) {
			console.log("üìç Matched Á¶ÅÂøåÁ†¥Ëß£Ë©±Ë°ì");
			return {
				category: "taboo_breaking",
				categoryKey: "tabooBreaking",
				color: "bg-purple-100 border-purple-300 text-purple-800",
				icon: "Shield",
			};
		}

		// Default to ÊÑüÊÉÖÈôçÊ∫´È°û
		return {
			category: "emotion_cooling",
			categoryKey: "emotionCooling",
			color: "bg-pink-100 border-pink-300 text-pink-800",
			icon: "Heart",
		};
	};

	const renderCategoryIcon = (iconName) => {
		switch (iconName) {
			case "Heart":
				return <Heart className="w-6 h-6" />;
			case "Globe":
				return <Users className="w-6 h-6" />;
			case "Shield":
				return <Target className="w-6 h-6" />;
			default:
				return <Heart className="w-6 h-6" />;
		}
	};

	const generateCoupleAnalysis = async () => {
		setLoading(true);
		try {
			console.log(
				"üìä EnhancedCoupleSpecificProblemSolution - Calling API with isSimplified:",
				isSimplified
			);

			const response = await fetch(
				"/api/couple-specific-problem-analysis",
				{
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify({
						femaleUser,
						maleUser,
						specificProblem,
						isSimplified,
					}),
				}
			);

			if (response.ok) {
				const data = await response.json();
				setAnalysisData(data);

				// Note: Complete data will be saved when subsections are ready
				console.log(
					"‚è≥ Base analysis ready, waiting for subsections..."
				);
			} else {
				// Try to get data from response even if not ok
				try {
					const errorData = await response.json();
					if (errorData.female && errorData.male) {
						setAnalysisData(errorData);

						// Note: Complete data will be saved when subsections are ready
						console.log(
							"‚è≥ Base analysis ready (from error response), waiting for subsections..."
						);
					} else {
						throw new Error("No valid data in response");
					}
				} catch (parseError) {
					throw new Error(
						`HTTP ${response.status}: ${response.statusText}`
					);
				}
			}
		} catch (error) {
			console.error("Analysis generation failed:", error);
			// Set error state with user's actual birth dates
			setAnalysisData({
				error: true,
				message: `${t("analysisFailed")}: ${error.message}. ${t("checkNetworkOrRetry")}`,
				female: {
					birthDate: formatBirthDate(femaleUser.birthDateTime),
					bazi: t("calculationFailed"),
					description: t("unableToGenerateAnalysis"),
					pillars: [
						t("calculating"),
						t("calculating"),
						t("calculating"),
						t("calculating"),
					],
				},
				male: {
					birthDate: formatBirthDate(maleUser.birthDateTime),
					bazi: t("calculationFailed"),
					description: t("unableToGenerateAnalysis"),
					pillars: [
						t("calculating"),
						t("calculating"),
						t("calculating"),
						t("calculating"),
					],
				},
			});
		} finally {
			setLoading(false);
		}
	};

	if (loading) {
		return (
			<div
				className="w-full bg-white shadow-lg"
				style={{
					padding: "clamp(24px, 6vw, 32px)",
					borderRadius: "clamp(12px, 3vw, 16px)",
				}}
			>
				<div className="flex flex-col items-center justify-center py-12 space-y-4">
					{/* Loading spinner */}
					<div className="w-8 h-8 border-b-2 border-pink-500 rounded-full animate-spin"></div>

					{/* È¢®Èà¥ loading image */}
					<div className="flex items-center justify-center">
						<Image
							src="/images/È¢®Ê∞¥Â¶π/È¢®Ê∞¥Â¶π-loading.png"
							alt="È¢®Èà¥ÈÅãÁÆó‰∏≠"
							width={120}
							height={120}
							className="object-contain"
						/>
					</div>

					{/* Loading text */}
					<div className="space-y-2 text-center">
						<div
							className="text-gray-700"
							style={{
								fontFamily: "Noto Sans HK, sans-serif",
								fontSize: "clamp(0.875rem, 2.5vw, 1rem)",
								fontWeight: 500,
							}}
						>
							{t("loadingMessage")}
						</div>
						<div
							className="text-gray-500"
							style={{
								fontFamily: "Noto Sans HK, sans-serif",
								fontSize: "clamp(0.75rem, 2vw, 0.875rem)",
								fontWeight: 400,
							}}
						>
							{t("loadingSubMessage")}
						</div>
					</div>
				</div>
			</div>
		);
	}

	// Show error state if analysis failed
	if (analysisData?.error) {
		return (
			<div
				className="w-full bg-white shadow-lg"
				style={{
					padding: "clamp(24px, 6vw, 32px)",
					borderRadius: "clamp(12px, 3vw, 16px)",
				}}
			>
				<div className="text-center">
					<div
						className="mx-auto mb-4 text-red-500"
						style={{
							width: "clamp(48px, 12vw, 64px)",
							height: "clamp(48px, 12vw, 64px)",
						}}
					>
						<Target className="w-full h-full" />
					</div>
					<h3
						className="mb-3 font-semibold text-red-800"
						style={{ fontSize: "clamp(16px, 4vw, 18px)" }}
					>
						ÂàÜÊûêÂ§±Êïó
					</h3>
					<p
						className="mb-4 text-gray-600"
						style={{ fontSize: "clamp(13px, 3.2vw, 15px)" }}
					>
						{analysisData.message}
					</p>
					<button
						onClick={() => {
							setAnalysisData(null);
							generateCoupleAnalysis();
						}}
						className="text-white transition-colors bg-pink-500 hover:bg-pink-600"
						style={{
							padding:
								"clamp(8px, 2vw, 12px) clamp(20px, 5vw, 24px)",
							borderRadius: "clamp(6px, 1.5vw, 8px)",
							fontSize: "clamp(13px, 3.2vw, 15px)",
						}}
					>
						ÈáçÊñ∞ÂàÜÊûê
					</button>
				</div>
			</div>
		);
	}

	const renderSectionsByCategory = () => {
		if (!problemCategory || !analysisData) return null;

		const { category } = problemCategory;

		if (category === "emotion_cooling") {
			// ÊÑüÊÉÖÈôçÊ∫´È°û: ChartDiagnosisSection + EmergencyFengShuiSection + RestartChemistrySection
			return (
				<div className="space-y-6 sm:space-y-8">
					<div className="mb-4 sm:mb-6">
						<h2
							className="font-bold text-[#374A37]"
							style={{
								fontSize: "clamp(28px, 7vw, 36px)",
								fontFamily: "Noto Serif TC, serif",
							}}
						>
							{t("sectionTitles.chartDiagnosis")}
						</h2>
					</div>
					<ChartDiagnosisSection
						femaleUser={femaleUser}
						maleUser={maleUser}
						analysisData={analysisData}
						savedData={subsectionData.chartDiagnosis}
						onDataReady={(data) =>
							handleSubsectionData("chartDiagnosis", data)
						}
						isSimplified={isSimplified}
					/>{" "}
					<div className="mb-4 sm:mb-6">
						<h2
							className="font-bold text-[#374A37]"
							style={{
								fontSize: "clamp(28px, 7vw, 36px)",
								fontFamily: "Noto Serif TC, serif",
							}}
						>
							È¢®Ê∞¥ÊÄ•Êïë
						</h2>
					</div>
					<div className="mb-6 sm:mb-8">
						<EmergencyFengShuiSection
							femaleUser={femaleUser}
							maleUser={maleUser}
							analysisData={analysisData}
							savedData={subsectionData.emergencyFengShui}
							onDataReady={(data) =>
								handleSubsectionData("emergencyFengShui", data)
							}
							isSimplified={isSimplified}
						/>
					</div>
					<div className="mb-4 sm:mb-6">
						<h2
							className="font-bold text-[#374A37]"
							style={{
								fontSize: "clamp(28px, 7vw, 36px)",
								fontFamily: "Noto Serif TC, serif",
							}}
						>
							ÈáçÂïüÈªòÂ•ë
						</h2>
					</div>
					<div className="mb-6 sm:mb-8">
						<RestartChemistrySection
							femaleUser={femaleUser}
							maleUser={maleUser}
							analysisData={analysisData}
							savedData={subsectionData.restartChemistry}
							onDataReady={(data) =>
								handleSubsectionData("restartChemistry", data)
							}
							isSimplified={isSimplified}
						/>
					</div>
				</div>
			);
		}

		if (category === "special_situation") {
			// ÁâπÊÆäÊÉÖÂ¢ÉÈ°û: StarChartGuidanceSection + FengShuiTransformationSection + RelationshipMethodSection
			return (
				<div className="space-y-6 sm:space-y-8">
					<div className="mb-4 sm:mb-6">
						<h2
							className="font-bold text-[#374A37]"
							style={{
								fontSize: "clamp(28px, 7vw, 36px)",
								fontFamily: "Noto Serif TC, serif",
							}}
						>
							{t("sectionTitles.starChartGuidance")}
						</h2>
					</div>
					<StarChartGuidanceSection
						femaleUser={femaleUser}
						maleUser={maleUser}
						analysisData={analysisData}
					/>

					<div className="mb-4 sm:mb-6">
						<h2
							className="font-bold text-[#374A37]"
							style={{
								fontSize: "clamp(28px, 7vw, 36px)",
								fontFamily: "Noto Serif TC, serif",
							}}
						>
							{t("sectionTitles.fengShuiTransformation")}
						</h2>
					</div>
					<div className="mb-6 sm:mb-8">
						<FengShuiTransformationSection
							femaleUser={femaleUser}
							maleUser={maleUser}
							analysisData={analysisData}
						/>
					</div>

					<div className="mb-4 sm:mb-6">
						<h2
							className="font-bold text-[#374A37]"
							style={{
								fontSize: "clamp(28px, 7vw, 36px)",
								fontFamily: "Noto Serif TC, serif",
							}}
						>
							Áõ∏ËôïÂøÉÊ≥ï
						</h2>
					</div>
					<div className="mb-6 sm:mb-8">
						<RelationshipMethodSection
							femaleUser={femaleUser}
							maleUser={maleUser}
							analysisData={analysisData}
						/>
					</div>
				</div>
			);
		}

		if (category === "taboo_breaking") {
			// Á¶ÅÂøåÁ†¥Ëß£Ë©±Ë°ì: KeyAnalysisSection + TargetedSuggestionsSection + RestartChemistrySection
			return (
				<div className="space-y-6 sm:space-y-8">
					<div className="mb-4 sm:mb-6">
						<h2
							className="font-bold text-[#374A37]"
							style={{
								fontSize: "clamp(28px, 7vw, 36px)",
								fontFamily: "Noto Serif TC, serif",
							}}
						>
							ÈóúÈçµÂàÜÊûê
						</h2>
					</div>
					<KeyAnalysisSection
						femaleUser={femaleUser}
						maleUser={maleUser}
						analysisData={analysisData}
					/>

					<div className="mb-4 sm:mb-6">
						<h2
							className="font-bold text-[#374A37]"
							style={{
								fontSize: "clamp(28px, 7vw, 36px)",
								fontFamily: "Noto Serif TC, serif",
							}}
						>
							{t("sectionTitles.targetedSuggestions")}
						</h2>
					</div>
					<div className="mb-6 sm:mb-8">
						<TargetedSuggestionsSection
							femaleUser={femaleUser}
							maleUser={maleUser}
							analysisData={analysisData}
						/>
					</div>

					<div className="mb-4 sm:mb-6">
						<h2
							className="font-bold text-[#374A37]"
							style={{
								fontSize: "clamp(28px, 7vw, 36px)",
								fontFamily: "Noto Serif TC, serif",
							}}
						>
							ÈáçÂïüÈªòÂ•ë
						</h2>
					</div>
					<div className="mb-6 sm:mb-8">
						<RestartChemistrySection
							femaleUser={femaleUser}
							maleUser={maleUser}
							analysisData={analysisData}
							isSimplified={isSimplified}
						/>
					</div>
				</div>
			);
		}

		return null;
	};

	return (
		<div className="w-full space-y-6 sm:space-y-8">
			{/* Main Analysis Section with New Layout */}
			<div
				className="flex flex-col gap-4 sm:gap-6 lg:flex-row"
				style={{ padding: "clamp(4px, 4vw, 4px)" }}
			>
				{/* Left Side: Large Compatibility Circle (Full Height) */}
				<div className="flex items-center justify-center py-6 sm:py-8 lg:w-1/3">
					<div className="relative">
						{/* Larger Circular Progress */}
						<div
							className="relative"
							style={{
								width: "clamp(240px, 60vw, 320px)",
								height: "clamp(240px, 60vw, 320px)",
							}}
						>
							<svg
								className="w-full h-full transform -rotate-90"
								viewBox="0 0 100 100"
							>
								{/* Background circle - Updated color and thickness */}
								<circle
									cx="50"
									cy="50"
									r="40"
									fill="none"
									stroke="#817E7E"
									strokeWidth="10"
								/>
								{/* Progress circle with gradient - Updated thickness */}
								<circle
									cx="50"
									cy="50"
									r="40"
									fill="none"
									stroke="url(#enhancedGradient)"
									strokeWidth="10"
									strokeLinecap="round"
									strokeDasharray={`${(compatibilityScore * 251.2) / 100} 251.2`}
									className="transition-all duration-1000 ease-out"
								/>
								{/* Gradient definition */}
								<defs>
									<linearGradient
										id="enhancedGradient"
										x1="0%"
										y1="0%"
										x2="100%"
										y2="0%"
									>
										<stop offset="0%" stopColor="#ec4899" />
										<stop
											offset="50%"
											stopColor="#f97316"
										/>
										<stop
											offset="100%"
											stopColor="#eab308"
										/>
									</linearGradient>
								</defs>
							</svg>
							{/* Score display */}
							<div className="absolute inset-0 flex flex-col items-center justify-center">
								<span
									className="font-bold text-amber-600"
									style={{
										fontSize: "clamp(48px, 12vw, 80px)",
									}}
								>
									{compatibilityScore}
								</span>
								<span
									className="mt-1 font-medium text-center text-gray-600 sm:mt-2"
									style={{
										fontSize: "clamp(14px, 3.5vw, 18px)",
									}}
								>
									{getCompatibilityLevel(compatibilityScore)}
								</span>
							</div>
						</div>
					</div>
				</div>

				{/* Right Side: BaZi Cards */}
				<div className="flex flex-col gap-4 sm:gap-6 lg:w-2/3">
					{/* BaZi Analysis Cards */}
					{analysisData && (
						<div className="flex flex-col gap-4 sm:gap-6">
							{/* Female BaZi Card */}
							<div
								className="overflow-hidden bg-white shadow-lg"
								style={{
									borderRadius: "clamp(20px, 5vw, 30px)",
								}}
							>
								<div
									className="bg-gradient-to-r from-pink-100 to-purple-100"
									style={{
										padding:
											"clamp(16px, 4vw, 24px) clamp(20px, 5vw, 24px)",
									}}
								>
									<div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
										<h3
											className="font-bold text-[#C74772]"
											style={{
												fontSize:
													"clamp(24px, 6vw, 36px)",
												fontFamily:
													"Noto Serif TC, serif",
											}}
										>
											‰Ω†ÁöÑÂÖ´Â≠ó
										</h3>
										<div
											className="bg-white border-2 border-[#C74772] rounded-full self-start sm:self-center"
											style={{
												padding:
													"clamp(6px, 1.5vw, 8px) clamp(8px, 2vw, 12px)",
											}}
										>
											<span
												className="text-[#C74772]"
												style={{
													fontSize:
														"clamp(11px, 2.8vw, 14px)",
												}}
											>
												{analysisData.female.birthDate}
											</span>
										</div>
									</div>
								</div>

								<div
									style={{
										padding: "clamp(16px, 4vw, 24px)",
									}}
								>
									{/* Four Pillars Display */}
									<div className="mb-4 sm:mb-6">
										<div className="flex flex-wrap gap-2">
											{analysisData.female.pillars?.map(
												(pillar, index) => (
													<div
														key={index}
														className="bg-white border border-[#DeaB20] rounded-full"
														style={{
															padding:
																"clamp(4px, 1vw, 6px) clamp(8px, 2vw, 12px)",
														}}
													>
														<span
															className="font-medium text-[#6F5100]"
															style={{
																fontSize:
																	"clamp(8px, 2.8vw, 14px)",
															}}
														>
															{pillar}
														</span>
													</div>
												)
											)}
										</div>
									</div>

									{/* Description */}
									<div
										className="leading-relaxed text-gray-700"
										style={{
											fontSize: "clamp(12px, 3vw, 14px)",
											lineHeight: "1.6",
											minHeight:
												"clamp(60px, 15vw, 80px)", // Ensure consistent height
										}}
									>
										{formatBaziDescription(
											analysisData.female.description
										)}
									</div>
								</div>
							</div>

							{/* Male BaZi Card */}
							<div
								className="overflow-hidden bg-white shadow-lg"
								style={{
									borderRadius: "clamp(20px, 5vw, 30px)",
								}}
							>
								<div
									className="bg-gradient-to-r from-blue-100 to-indigo-100"
									style={{
										padding:
											"clamp(16px, 4vw, 24px) clamp(20px, 5vw, 24px)",
									}}
								>
									<div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
										<h3
											className="font-bold text-[#C74772]"
											style={{
												fontSize:
													"clamp(24px, 6vw, 36px)",
												fontFamily:
													"Noto Serif TC, serif",
											}}
										>
											‰º¥‰æ∂ÂÖ´Â≠ó
										</h3>
										<div
											className="bg-white border-2 border-[#C74772] rounded-full self-start sm:self-center"
											style={{
												padding:
													"clamp(6px, 1.5vw, 8px) clamp(8px, 2vw, 12px)",
											}}
										>
											<span
												className="text-[#C74772]"
												style={{
													fontSize:
														"clamp(11px, 2.8vw, 14px)",
												}}
											>
												{analysisData.male.birthDate}
											</span>
										</div>
									</div>
								</div>

								<div
									style={{
										padding: "clamp(16px, 4vw, 24px)",
									}}
								>
									{/* Four Pillars Display */}
									<div className="mb-4 sm:mb-6">
										<div className="flex flex-wrap gap-2">
											{analysisData.male.pillars?.map(
												(pillar, index) => (
													<div
														key={index}
														className="bg-white border border-[#DeaB20] rounded-full"
														style={{
															padding:
																"clamp(4px, 1vw, 6px) clamp(8px, 2vw, 12px)",
														}}
													>
														<span
															className="font-medium text-[#6F5100]"
															style={{
																fontSize:
																	"clamp(8px, 2.8vw, 14px)",
															}}
														>
															{pillar}
														</span>
													</div>
												)
											)}
										</div>
									</div>

									{/* Description */}
									<div
										className="leading-relaxed text-gray-700"
										style={{
											fontSize: "clamp(12px, 3vw, 14px)",
											lineHeight: "1.6",
											minHeight:
												"clamp(60px, 15vw, 80px)", // Ensure consistent height
										}}
									>
										{formatBaziDescription(
											analysisData.male.description
										)}
									</div>
								</div>
							</div>
						</div>
					)}
				</div>
			</div>

			{/* Problem Category Section */}
			{specificProblem && problemCategory && (
				<div
					className="mb-6 rounded-full sm:mb-8"
					style={{
						background: "linear-gradient(45deg, #b4003c, #d09900)",
						padding: "clamp(3px, 0.8vw, 4px)",
					}}
				>
					<div
						className="bg-white rounded-full"
						style={{ padding: "clamp(6px, 1.5vw, 8px)" }}
					>
						<div className="flex items-center justify-center">
							<div className="flex-1 text-center">
								<div className="flex items-center justify-center gap-2 mb-2">
									<h3
										className="font-bold text-gray-800"
										style={{
											fontSize: "clamp(16px, 4vw, 18px)",
										}}
									>
										{t("problemType")}Ôºö
										{t(
											`problemCategories.${problemCategory.categoryKey}`
										)}
									</h3>
								</div>
								<div
									style={{
										padding: "clamp(6px, 1.5vw, 8px)",
									}}
								>
									<p
										className="leading-relaxed text-[#515151] text-center"
										style={{
											fontSize: "clamp(20px, 5vw, 32px)",
										}}
									>
										{specificProblem}
									</p>
								</div>
							</div>
						</div>
					</div>
				</div>
			)}

			{/* Dynamic Sections Based on Category */}
			{renderSectionsByCategory()}
		</div>
	);
};

export default EnhancedCoupleSpecificProblemSolution;
