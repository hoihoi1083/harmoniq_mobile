"use client";

import { useState, useEffect } from "react";
import { useSession } from "next-auth/react";
import Image from "next/image";
import { useTranslations } from "next-intl";
import { ComponentErrorBoundary } from "./ErrorHandling";
import { useCoupleAnalysis } from "@/contexts/CoupleAnalysisContext";
import { getCoupleComponentData } from "@/utils/coupleComponentDataStore";
import { saveComponentContentWithUser } from "@/utils/simpleCoupleContentSave";

export default function CoupleCoreSuggestion({
	user1,
	user2,
	currentYear = 2025,
	isSimplified = false,
}) {
	const t = useTranslations("coupleReport.coupleCoreSuggestion");
	const { data: session } = useSession();
	const { coupleCoreSuggestionCache, setCoupleCoreSuggestionCache } =
		useCoupleAnalysis();

	const [analysisData, setAnalysisData] = useState(null);
	const [isLoading, setIsLoading] = useState(true);
	const [activeCategoryIndex, setActiveCategoryIndex] = useState(0);
	const [error, setError] = useState(null);

	// Generate couple core suggestion analysis using both partners' birth info
	const generateCoupleCoreSuggestionAnalysis = async (user1, user2, year) => {
		try {
			console.log("ðŸ“¤ API Request Data:", {
				user1Info: {
					birthday: user1?.birthDateTime || "",
					gender: user1?.gender || "male",
					name: user1?.name || "ç”·æ–¹",
				},
				user2Info: {
					birthday: user2?.birthDateTime || "",
					gender: user2?.gender || "female",
					name: user2?.name || "å¥³æ–¹",
				},
				currentYear: year,
				concern: "æ„Ÿæƒ…",
			});

			const response = await fetch(
				"/api/couple-core-suggestion-analysis",
				{
					method: "POST",
					headers: {
						"Content-Type": "application/json",
					},
					body: JSON.stringify({
						user1Info: {
							birthday: user1?.birthDateTime || "",
							gender: user1?.gender || "male",
							name: user1?.name || "ç”·æ–¹",
						},
						user2Info: {
							birthday: user2?.birthDateTime || "",
							gender: user2?.gender || "female",
							name: user2?.name || "å¥³æ–¹",
						},
						currentYear: year,
						concern: "æ„Ÿæƒ…", // Default concern for couple analysis
						isSimplified: isSimplified, // Add language preference
					}),
				}
			);
			if (!response.ok) {
				throw new Error(`API request failed: ${response.status}`);
			}

			const result = await response.json();

			console.log("ðŸ“¥ API Response:", result);
			console.log("ðŸ“¥ API Success:", result.success);
			console.log("ðŸ“¥ API Analysis:", result.analysis);
			if (result.analysis?.content) {
				console.log(
					"ðŸ“¥ API Content Preview:",
					result.analysis.content.substring(0, 500) + "..."
				);
			}

			if (!result.success) {
				throw new Error(
					result.error || "Couple core suggestion analysis failed"
				);
			}

			// Transform AI response into component structure
			return transformCoupleAIResponseToComponentData(
				result.analysis,
				user1,
				user2,
				year
			);
		} catch (error) {
			console.error(
				"ðŸš¨ Couple core suggestion AI analysis error:",
				error
			);
			console.error("ðŸš¨ Error details:", error.message);
			console.error("ðŸš¨ Stack trace:", error.stack);
			console.error("ðŸš¨ Triggering fallback due to API failure");
			// Return minimal fallback structure when AI fails
			return getCoupleFallbackComponentData(year, user1, user2);
		}
	};

	// Transform AI response to component data structure
	// Utility function to clean markdown formatting
	const cleanMarkdownFormatting = (text) => {
		if (!text) return text;

		// Remove ** markdown formatting
		return text
			.replace(/\*\*(.*?)\*\*/g, "$1") // Remove ** bold markers
			.replace(/\*\*\s*/g, "") // Remove hanging ** markers
			.replace(/\s*\*\*/g, ""); // Remove trailing ** markers
	};

	// Utility function to convert simplified Chinese to traditional Chinese
	const convertToTraditionalChinese = (text) => {
		if (!text) return text;

		const conversionMap = {
			è®¡åˆ’: "è¨ˆåŠƒ",
			çº¦ä¼š: "ç´„æœƒ",
			æ—¶æœºä¸Žæ–¹æ³•: "æ™‚æ©Ÿèˆ‡æ–¹æ³•",
			æ—¶æœº: "æ™‚æ©Ÿ",
			å‘å±•: "ç™¼å±•",
			è¿‡ç¨‹: "éŽç¨‹",
			è¯´è¯: "èªªè©±",
			æ²Ÿé€š: "æºé€š",
			ç»æµŽ: "ç¶“æ¿Ÿ",
			è´¢åŠ¡: "è²¡å‹™",
			è¯šå®ž: "èª å¯¦",
			è¯šä¿¡: "èª ä¿¡",
			å­¦ä¹ : "å­¸ç¿’",
			å®žè·µ: "å¯¦è¸",
			å®žé™…: "å¯¦éš›",
			å®žçŽ°: "å¯¦ç¾",
			åº”è¯¥: "æ‡‰è©²",
			åº”å½“: "æ‡‰ç•¶",
			é€‰æ‹©: "é¸æ“‡",
			çŽ¯å¢ƒ: "ç’°å¢ƒ",
			å›´ç»•: "åœç¹ž",
			åˆ›é€ : "å‰µé€ ",
			è¥é€ : "ç‡Ÿé€ ",
			ç»´æŠ¤: "ç¶­è­·",
			ç»´æŒ: "ç¶­æŒ",
			å…³ç³»: "é—œä¿‚",
			é—®é¢˜: "å•é¡Œ",
			å¤„ç†: "è™•ç†",
			è”ç³»: "è¯ç³»",
			è¿žæŽ¥: "é€£æŽ¥",
			è®¾è®¡: "è¨­è¨ˆ",
			è£…é¥°: "è£é£¾",
			é£Žæ ¼: "é¢¨æ ¼",
			æ ·å¼: "æ¨£å¼",
			é¢œè‰²: "é¡è‰²",
			é¢œå€¼: "é¡å€¼",
			è´¨é‡: "è³ªé‡",
			è´¨æ„Ÿ: "è³ªæ„Ÿ",
			å…±åŒåˆ¶å®šå¹´åº¦è®¡åˆ’: "å…±åŒåˆ¶å®šå¹´åº¦è¨ˆåŠƒ",
			åˆ¶å®š: "åˆ¶å®š",
			è®¨è®º: "è¨Žè«–",
			å†³å®š: "æ±ºå®š",
			é¡¹ç›®: "é …ç›®",
			è§„åˆ’: "è¦åŠƒ",
			ç®¡ç†: "ç®¡ç†",
			èµ„æº: "è³‡æº",
			èµ„é‡‘: "è³‡é‡‘",
			èµ„äº§: "è³‡ç”¢",
			åè°ƒ: "å”èª¿",
			åå•†: "å”å•†",
			è°ƒæ•´: "èª¿æ•´",
			è°ƒèŠ‚: "èª¿ç¯€",
			è°ƒå’Œ: "èª¿å’Œ",
			è¿æ°”: "é‹æ°£",
			è¿åŠ¿: "é‹å‹¢",
			è¡ŒåŠ¨å»ºè®®: "è¡Œå‹•å»ºè­°",
			æ—¶æœºä¸Žæ–¹æ³•: "æ™‚æ©Ÿèˆ‡æ–¹æ³•",
			å‡æ¸©: "å‡æº«",
			åº†å…¸: "æ…¶å…¸",
			æ¸©æš–: "æº«æš–",
			åŽ‹åŠ›: "å£“åŠ›",
			èŠ‚ç‚¹: "ç¯€é»ž",
			çº¦ä¼š: "ç´„æœƒ",
			ç»¿è‰²: "ç¶ è‰²",
			ç»ƒä¹ : "ç·´ç¿’",
			ä¹ æƒ¯: "ç¿’æ…£",
		};

		let convertedText = text;
		for (const [simplified, traditional] of Object.entries(conversionMap)) {
			const regex = new RegExp(simplified, "g");
			convertedText = convertedText.replace(regex, traditional);
		}

		return convertedText;
	};

	// Combined function to clean and convert content
	const cleanContent = (text) => {
		if (!text) return text;

		// First clean markdown formatting, then convert to traditional Chinese
		let cleaned = cleanMarkdownFormatting(text);
		cleaned = convertToTraditionalChinese(cleaned);

		return cleaned;
	};

	const transformCoupleAIResponseToComponentData = (
		analysisData,
		user1,
		user2,
		year
	) => {
		console.log("ðŸ”„ Transforming AI response to component data...");
		console.log("ðŸ”„ Analysis data:", analysisData);
		console.log(
			"ðŸ”„ Content preview:",
			analysisData?.content?.substring(0, 300) + "..."
		);

		// Create category structure for couple analysis
		const coupleCategories = [
			{
				title: t("tabs.relationship.title"),
				subtitle: t("tabs.relationship.subtitle"),
				icon: "/images/report/star.png",
				color: "bg-[#DEAB20]",
				content: extractCategoryContent(
					analysisData.content,
					"é—œä¿‚ç™¼å±•å»ºè­°",
					"é—œä¿‚ç™¼å±•ç­–ç•¥"
				),
			},
			{
				title: t("tabs.communication.title"),
				subtitle: t("tabs.communication.subtitle"),
				icon: "/images/report/chat.png",
				color: "bg-[#8A71C7]",
				content: extractCategoryContent(
					analysisData.content,
					"æºé€šå»ºè­°",
					"æºé€šèƒ½é‡æŒ‡å—"
				),
			},
			{
				title: t("tabs.energy.title"),
				subtitle: t("tabs.energy.subtitle"),
				icon: "/images/report/fengshui.png",
				color: "bg-[#8FA940]",
				content: extractCategoryContent(
					analysisData.content,
					"èƒ½é‡æå‡å»ºè­°",
					"èƒ½é‡æå‡æ–¹æ¡ˆ"
				),
			},
			{
				title: t("tabs.taboos.title"),
				subtitle: t("tabs.taboos.subtitle"),
				icon: "/images/report/warning.png",
				color: "bg-[#B4003C]",
				content: extractCategoryContent(
					analysisData.content,
					"æ„Ÿæƒ…é—œä¿‚ç¦å¿Œ",
					"æ„Ÿæƒ…é—œä¿‚ç¦å¿Œ"
				),
			},
		];

		// Create icon list
		const coupleIconList = coupleCategories.map((category, index) => ({
			icon: category.icon,
			label: category.title,
			color: category.color,
			active: index === 0,
		}));

		return {
			title: "å¤«å¦»é–‹é‹å»ºè­°",
			subtitle: `${user1?.name || "ç”·æ–¹"} & ${user2?.name || "å¥³æ–¹"} æ„Ÿæƒ…æŒ‡å—`,
			coreIcon: "ðŸ’•",
			iconColor: "bg-[#B4003C]",
			coreTitle: "å¤«å¦»å’Œè«§",
			coreIconList: coupleIconList,
			coreCategories: coupleCategories,
			motto: extractCoupleMottoFromContent(analysisData.content),
			coreStrategy: "å¤«å¦»å…«å­—åˆç›¤ï¼Œäº”è¡Œèª¿å’Œï¼Œæ„Ÿæƒ…é•·ä¹…",
			year,
			concern: "æ„Ÿæƒ…",
			user1Birthday: user1?.birthDateTime || "",
			user2Birthday: user2?.birthDateTime || "",
			user1Name: user1?.name || "ç”·æ–¹",
			user2Name: user2?.name || "å¥³æ–¹",
			fullContent: analysisData.content,
			timestamp: analysisData.timestamp,
		};
	};

	// Extract content for specific category
	const extractCategoryContent = (
		fullContent,
		categoryTitle,
		sectionPattern
	) => {
		try {
			// For æ„Ÿæƒ…é—œä¿‚ç¦å¿Œ, first try to use actual provided content if available
			if (categoryTitle === "æ„Ÿæƒ…é—œä¿‚ç¦å¿Œ") {
				// Enhanced detection: look for the specific structure patterns that AI should generate
				if (
					fullContent &&
					(fullContent.includes("æºé€šç¦å¿Œ") ||
						fullContent.includes("è¡Œç‚ºç¦å¿Œ") ||
						fullContent.includes("ç’°å¢ƒç¦å¿Œ") ||
						(fullContent.includes("å¥³æ–¹å¿Œç”¨") &&
							fullContent.includes("ç”·æ–¹å¿Œç”¨")) ||
						fullContent.includes("ç´„æœƒé¿é–‹") ||
						fullContent.includes("åŒæˆ¿ç¦å¿Œ"))
				) {
					return parseRelationshipTaboosContent(fullContent);
				} else {
					return getFallbackCategoryContent(categoryTitle);
				}
			} // Try to find the specific section using multiple patterns
			const patterns = [
				new RegExp(
					`${sectionPattern}[ï¼š:]?([\\s\\S]*?)(?=(?:ä¸€ã€|äºŒã€|ä¸‰ã€|å››ã€|###|$))`,
					"g"
				),
				new RegExp(
					`${categoryTitle}[ï¼š:]?([\\s\\S]*?)(?=(?:é—œä¿‚ç™¼å±•|æºé€šå»ºè­°|èƒ½é‡æå‡|æ„Ÿæƒ…é—œä¿‚|$))`,
					"g"
				),
				new RegExp(`ã€${categoryTitle}ã€‘([\\s\\S]*?)(?=ã€|$)`, "g"),
			];

			for (let pattern of patterns) {
				pattern.lastIndex = 0;
				const match = pattern.exec(fullContent);
				if (match && match[1] && match[1].trim().length > 50) {
					// Special handling for different categories
					if (categoryTitle === "é—œä¿‚ç™¼å±•å»ºè­°") {
						return parseRelationshipDevelopmentContent(
							match[1].trim()
						);
					} else if (categoryTitle === "æºé€šå»ºè­°") {
						return parseCommunicationAdviceContent(match[1].trim());
					} else if (categoryTitle === "èƒ½é‡æå‡å»ºè­°") {
						return parseEnergyEnhancementContent(match[1].trim());
					} else if (categoryTitle === "æ„Ÿæƒ…é—œä¿‚ç¦å¿Œ") {
						return parseRelationshipTaboosContent(match[1].trim());
					}
					return cleanAndStructureContent(match[1].trim());
				}
			}

			// If no specific content found, return default
			return getFallbackCategoryContent(categoryTitle);
		} catch (error) {
			console.error("Error extracting category content:", error);
			return getFallbackCategoryContent(categoryTitle);
		}
	};

	// Parse communication advice content into structured format
	const parseCommunicationAdviceContent = (content) => {
		try {
			// Extract communication styles for both partners
			const maleStyleMatch = content.match(
				/ç”·æ–¹([^ï¼Œ]*?(?:åœŸæ€§|æ²‰ç©©|å‚¾è½|åŒ…å®¹)[^ï¼Œ]*?)ï¼Œ/
			);
			const femaleStyleMatch = content.match(
				/å¥³æ–¹([^ã€‚]*?(?:ç«æ€§|ç›´çŽ‡|è¡¨é”|æƒ…ç·’)[^ã€‚]*?)ã€‚/
			);

			// Extract communication methods and timing
			const methodMatch = content.match(/å»ºè­°æŽ¡ç”¨[^ã€‚]*?([^ã€‚]*?)ã€‚/);
			const timingMatch = content.match(/æœ€ä½³æºé€šæ™‚è¾°([^ã€‚]*?)ã€‚/);
			const obstacleMatch =
				content.match(/å¯èƒ½å‡ºç¾çš„æºé€šéšœç¤™([^ã€‚]*?)ã€‚/);
			const solutionMatch = content.match(/å¯æŽ¡ç”¨[^ã€‚]*?([^ã€‚]*?)ã€‚/);

			// Extract strategies from AI content for specific conflict types
			const extractStrategiesForType = (type) => {
				// Look for patterns like "æ„è¦‹ä¸åˆ" followed by strategies
				const typePattern = new RegExp(
					`${type}[^ï¼š]*ï¼š?([^\\n]*(?:ç”·æ–¹[^\\n]*å¥³æ–¹[^\\n]*|å¥³æ–¹[^\\n]*ç”·æ–¹[^\\n]*)?[^\\n]*)`,
					"g"
				);
				const matches = content.match(typePattern);

				if (matches && matches.length > 0) {
					const typeContent = matches[0];
					// Extract male strategy
					const maleStrategyMatch =
						typeContent.match(/ç”·æ–¹[^ï¼š]*ï¼š([^å¥³æ–¹]*)/);
					// Extract female strategy
					const femaleStrategyMatch =
						typeContent.match(/å¥³æ–¹[^ï¼š]*ï¼š([^ç”·æ–¹]*)/);

					return {
						male: maleStrategyMatch
							? maleStrategyMatch[1]
									.trim()
									.replace(/[ï¼Œã€‚]*$/, "")
							: null,
						female: femaleStrategyMatch
							? femaleStrategyMatch[1]
									.trim()
									.replace(/[ï¼Œã€‚]*$/, "")
							: null,
					};
				}

				// If no specific strategies found, generate based on elemental analysis
				return generateElementalStrategies(type, content);
			};

			// Generate strategies based on elemental characteristics from content
			const generateElementalStrategies = (conflictType, content) => {
				// Extract elemental characteristics from content
				const isMaleEarth = /ç”·æ–¹.*åœŸ|åœŸæ€§.*ç”·æ–¹|å·±åœŸ.*ç”·æ–¹/.test(
					content
				);
				const isFemaleGold = /å¥³æ–¹.*é‡‘|é‡‘æ€§.*å¥³æ–¹|è¾›é‡‘.*å¥³æ–¹/.test(
					content
				);

				// Default to detected elemental types
				const maleElement = isMaleEarth ? "åœŸ" : "åœŸ"; // Default to Earth
				const femaleElement = isFemaleGold ? "é‡‘" : "é‡‘"; // Default to Metal

				const strategies = {
					è¡çªé¡žåž‹: {
						male:
							maleElement === "åœŸ"
								? "ç©©å®šåŒ…å®¹ï¼Œå…ˆè½å¾Œèªªï¼šã€Œæˆ‘ç†è§£ä½ çš„æƒ³æ³•ï¼Œè®“æˆ‘å€‘ä¸€èµ·æƒ³è¾¦æ³•ã€"
								: "ä»¥åœŸæ€§åŒ…å®¹åŠ›åŒ–è§£è¡çªï¼Œé¿å…ç›´æŽ¥å°æŠ—",
						female:
							femaleElement === "é‡‘"
								? "ç†æ€§åˆ†æžï¼Œæå‡ºæ–¹æ¡ˆï¼šã€Œé€™å€‹å•é¡Œçš„é—œéµæ˜¯...æˆ‘å»ºè­°æˆ‘å€‘å¯ä»¥...ã€"
								: "ç™¼æ®é‡‘æ€§é‚è¼¯æ€ç¶­ï¼Œæå‡ºå…·é«”è§£æ±ºæ–¹æ¡ˆ",
					},
					æ„è¦‹ä¸åˆ: {
						male:
							maleElement === "åœŸ"
								? "åœŸæ€§ç©©é‡ï¼Œæ±‚åŒå­˜ç•°ï¼šã€Œé›–ç„¶çœ‹æ³•ä¸åŒï¼Œä½†æˆ‘å€‘çš„ç›®æ¨™æ˜¯ä¸€è‡´çš„ã€"
								: "ä»¥ç©©é‡æ…‹åº¦å°‹æ‰¾å…±åŒé»ž",
						female:
							femaleElement === "é‡‘"
								? "é‡‘æ€§ç²¾æº–ï¼Œæ•¸æ“šèªªè©±ï¼šã€Œæˆ‘å€‘ç”¨äº‹å¯¦å’Œæ•¸æ“šä¾†åˆ†æžé€™å€‹å•é¡Œã€"
								: "ä»¥äº‹å¯¦å’Œé‚è¼¯ç‚ºåŸºç¤Žé€²è¡Œè¨Žè«–",
					},
					æƒ…ç·’ä½Žè½: {
						male:
							maleElement === "åœŸ"
								? "åœŸæ€§æº«åŽšï¼Œè¡Œå‹•æ”¯æŒï¼šé»˜é»˜é™ªä¼´ï¼Œæä¾›å¯¦éš›å¹«åŠ©ï¼ˆæº–å‚™æº«é£Ÿã€å®‰æŽ’ä¼‘æ¯ï¼‰"
								: "ä»¥å¯¦éš›è¡Œå‹•æä¾›æ”¯æŒå’Œå®‰æ…°",
						female:
							femaleElement === "é‡‘"
								? "é‡‘æ€§ç†æ€§ï¼Œæº«å’Œå¼•å°Žï¼šã€Œæˆ‘çŸ¥é“ä½ ç¾åœ¨å¾ˆé›£å—ï¼Œæˆ‘å€‘å¯ä»¥è«‡è«‡å—Žï¼Ÿã€"
								: "ç†æ€§åˆ†æžå•é¡ŒåŽŸå› ï¼Œæä¾›è§£æ±ºæ€è·¯",
					},
					è¦ªå‹å¹²æ¶‰å•é¡Œ: {
						male:
							maleElement === "åœŸ"
								? "åœŸæ€§æ“”ç•¶ï¼Œæ˜Žç¢ºç•Œç·šï¼šã€Œé€™æ˜¯æˆ‘å€‘çš„äº‹ï¼Œæˆ‘æœƒè™•ç†å¥½ã€"
								: "æ‰¿æ“”è²¬ä»»ï¼Œæ˜Žç¢ºç«‹å ´å’Œç•Œç·š",
						female:
							femaleElement === "é‡‘"
								? "é‡‘æ€§æžœæ–·ï¼Œå»ºç«‹åŽŸå‰‡ï¼šã€Œæˆ‘å€‘éœ€è¦è¨­ç«‹æ¸…æ¥šçš„ç•Œç·šå’ŒåŽŸå‰‡ã€"
								: "åˆ¶å®šæ˜Žç¢ºè¦å‰‡ï¼Œå …æŒåŽŸå‰‡æ€§ç«‹å ´",
					},
				};

				return strategies[conflictType] || { male: null, female: null };
			};

			// Extract strategies for different conflict types
			const conflictStrategies = {
				è¡çªé¡žåž‹: extractStrategiesForType("è¡çªé¡žåž‹"),
				æ„è¦‹ä¸åˆ: extractStrategiesForType("æ„è¦‹ä¸åˆ"),
				æƒ…ç·’ä½Žè½: extractStrategiesForType("æƒ…ç·’ä½Žè½"),
				è¦ªå‹å¹²æ¶‰: extractStrategiesForType("è¦ªå‹å¹²æ¶‰"),
			};

			// Create structured communication content
			const communicationSections = [];

			// Partner communication styles section
			const stylesSection = {
				title: "æºé€šé¢¨æ ¼åˆ†æž",
				type: "partner-styles",
				maleStyle: maleStyleMatch
					? cleanContent(maleStyleMatch[1].trim())
					: "åœŸæ€§æ²‰ç©©æ“…é•·å‚¾è½",
				femaleStyle: femaleStyleMatch
					? cleanContent(femaleStyleMatch[1].trim())
					: "ç«æ€§ç›´çŽ‡éœ€è¦è¡¨é”ç©ºé–“",
			};

			// Practical application section with male/female strategies
			const practicalSection = {
				title: "å¯¦éš›æ‡‰ç”¨",
				type: "practical-application",
				subsections: [
					{
						title: "è¡çªé¡žåž‹",
						maleStrategy:
							conflictStrategies["è¡çªé¡žåž‹"].male ||
							"å…ˆèªå¯å†è£œå……ï¼šã€Œä½ èªªçš„Xéƒ¨åˆ†å¾ˆæœ‰é“ç†ï¼Œæˆ‘è£œå……Y...ã€",
						femaleStrategy:
							conflictStrategies["è¡çªé¡žåž‹"].female ||
							"ç”¨é¸é …ä»£æ›¿è³ªå•ï¼šã€ŒAæˆ–Bæ–¹æ¡ˆä½ è¦ºå¾—å“ªå€‹å¯è¡Œï¼Ÿã€",
					},
					{
						title: "æ„è¦‹ä¸åˆ",
						maleStrategy:
							conflictStrategies["æ„è¦‹ä¸åˆ"].male ||
							"å…ˆèªå¯å†è£œå……ï¼šã€Œä½ èªªçš„Xéƒ¨åˆ†å¾ˆæœ‰é“ç†ï¼Œæˆ‘è£œå……Y...ã€",
						femaleStrategy:
							conflictStrategies["æ„è¦‹ä¸åˆ"].female ||
							"ç”¨é¸é …ä»£æ›¿è³ªå•ï¼šã€ŒAæˆ–Bæ–¹æ¡ˆä½ è¦ºå¾—å“ªå€‹å¯è¡Œï¼Ÿã€",
					},
					{
						title: "æƒ…ç·’ä½Žè½",
						maleStrategy:
							conflictStrategies["æƒ…ç·’ä½Žè½"].male ||
							"è‚¢é«”æŽ¥è§¸>è¨€èªžï¼ˆè¼•æ‹èƒŒã€éžç†±é£²ï¼‰",
						femaleStrategy:
							conflictStrategies["æƒ…ç·’ä½Žè½"].female ||
							"åˆ†äº«è‡ªèº«é¡žä¼¼ç¶“æ­·ï¼ˆä¸»æ°´æ¯”åŠ«åŠ©å…±æƒ…ï¼‰",
					},
					{
						title: "è¦ªå‹å¹²æ¶‰å•é¡Œ",
						maleStrategy:
							conflictStrategies["è¦ªå‹å¹²æ¶‰"].male ||
							"æ˜Žç¢ºç«‹å ´ï¼šã€Œæˆ‘æœƒè™•ç†ã€+äº‹å¾ŒåŒæ­¥çµæžœ",
						femaleStrategy:
							conflictStrategies["è¦ªå‹å¹²æ¶‰"].female ||
							"é è¨­ã€Œé˜²ç«ç‰†ã€ï¼šã€Œé€™äº‹æˆ‘å€‘è‡ªå·±æ±ºå®šã€",
					},
				],
				timing: timingMatch
					? cleanContent(timingMatch[1].trim())
					: "å·³æ™‚ï¼ˆ9-11æ™‚ï¼‰èˆ‡åˆæ™‚ï¼ˆ11-13æ™‚ï¼‰",
				methods: methodMatch
					? cleanContent(methodMatch[1].trim())
					: "åœŸç«ç›¸ç”Ÿæºé€šæ³•",
			};

			return {
				type: "communication-structure",
				sections: [stylesSection, practicalSection],
			};
		} catch (error) {
			console.error("Error parsing communication advice content:", error);
			return { type: "text", content: cleanContent(content) };
		}
	};

	// Helper functions to extract content dynamically from AI-generated text
	const extractActionAdvice = (content, gender) => {
		console.log(`ðŸ” Extracting action advice for ${gender}`);

		// Try multiple patterns to handle different formats
		const patterns = [
			// Pattern 1: API format with ** markers - FIXED for actual API response
			`\\*\\*${gender}æå‡å»ºè­°[ï¼š]*\\*\\*[\\s\\S]*?è¡Œå‹•å»ºè­°[ï¼š]*([\\s\\S]*?)(?=é–‹é‹ç‰©|\\*\\*å¥³æ–¹|\\*\\*å…±åŒ|$)`,
			// Pattern 2: Direct search in the content
			`${gender}æå‡å»ºè­°[\\s\\S]*?è¡Œå‹•å»ºè­°[ï¼š]*([\\s\\S]*?)(?=é–‹é‹ç‰©|${gender === "ç”·æ–¹" ? "å¥³æ–¹" : "å…±åŒ"}|$)`,
		];

		for (let pattern of patterns) {
			const regex = new RegExp(pattern, "i");
			const match = content.match(regex);

			console.log(`ðŸ” Pattern: ${pattern}`);
			console.log(`ðŸ” Match result:`, match);

			if (match && match[1]) {
				console.log(
					`âœ… Found action advice match for ${gender}:`,
					match[1]
				);
				const actionText = match[1].trim();

				// Handle bullet points (â€¢) - primary format in API
				let actionItems = actionText
					.split(/â€¢|\n/)
					.map((item) => cleanContent(item.trim()))
					.filter(
						(item) =>
							item.length > 5 &&
							!item.includes("é–‹é‹ç‰©") &&
							!item.includes("å¥³æ–¹") &&
							!item.includes("å…±åŒ")
					); // Filter out unwanted content

				console.log(
					`ðŸ“‹ Processed action items for ${gender}:`,
					actionItems
				);

				if (actionItems && actionItems.length > 0) {
					return actionItems.slice(0, 3);
				}
			}
		}

		console.log(`âŒ No action advice found for ${gender}, trying fallback`);

		// Direct pattern matching based on current API format
		const directPattern = new RegExp(
			`\\*\\*${gender}æå‡å»ºè­°[ï¼š]*\\*\\*[\\s\\S]*?â€¢([^â€¢]*?)â€¢([^â€¢]*?)(?=é–‹é‹ç‰©|\\*\\*|$)`,
			"i"
		);
		const directMatch = content.match(directPattern);
		if (directMatch) {
			const items = [];
			if (directMatch[1]) items.push(cleanContent(directMatch[1].trim()));
			if (directMatch[2]) items.push(cleanContent(directMatch[2].trim()));
			console.log(`âœ… Direct pattern found items for ${gender}:`, items);
			return items;
		}

		return [];
	};

	const extractAccessories = (content, gender) => {
		console.log(`ðŸ” Extracting accessories for ${gender}`);

		// Try multiple patterns to handle different formats
		const patterns = [
			// Pattern 1: API format with ** markers - FIXED for actual response
			`\\*\\*${gender}æå‡å»ºè­°[ï¼š]*\\*\\*[\\s\\S]*?é–‹é‹ç‰©[ï¼š]*([\\s\\S]*?)(?=\\*\\*å¥³æ–¹|\\*\\*å…±åŒ|\\*\\*|$)`,
			// Pattern 2: Without ** markers
			`${gender}æå‡å»ºè­°[\\s\\S]*?é–‹é‹ç‰©[ï¼š]*([\\s\\S]*?)(?=${gender === "ç”·æ–¹" ? "å¥³æ–¹" : "å…±åŒ"}|$)`,
		];

		for (let pattern of patterns) {
			const regex = new RegExp(pattern, "i");
			const match = content.match(regex);

			console.log(`ðŸ” Accessories pattern: ${pattern}`);
			console.log(`ðŸ” Accessories match:`, match);

			if (match && match[1]) {
				console.log(
					`âœ… Found accessories match for ${gender}:`,
					match[1]
				);
				const accessoryText = cleanContent(
					match[1].trim().replace(/^\s*ï¼š\s*/, "")
				);
				// Split by common separators and clean up - handle API format "item1ã€item2ã€item3"
				const accessories = accessoryText
					.split(/[ã€ï¼Œ,]/)
					.map((item) => cleanContent(item.trim()))
					.filter(
						(item) =>
							item.length > 0 &&
							!item.includes("å¥³æ–¹") &&
							!item.includes("å…±åŒ") &&
							!item.includes("å»ºè­°")
					);

				console.log(
					`ðŸ“‹ Processed accessories for ${gender}:`,
					accessories
				);
				return accessories.length > 0 ? accessories : [accessoryText];
			}
		}

		console.log(`âŒ No accessories found for ${gender}, trying fallback`);

		// Enhanced fallback: look for specific accessory mentions
		const fallbackPattern = new RegExp(
			`${gender}[\\s\\S]*?([^ã€‚]*(?:æ°´æ™¶|é …éŠ|æ‰‹éŠ|èŒ¶å…·|è…•éŒ¶|çŸ³è‹±)[^ã€‚]*ã€‚?)`,
			"g"
		);
		const fallbackMatches = content.match(fallbackPattern);
		if (fallbackMatches && fallbackMatches.length > 0) {
			return fallbackMatches
				.map((match) => cleanContent(match.trim()))
				.slice(0, 3);
		}

		return [];
	};

	const extractWeeklyRitual = (content) => {
		// Try multiple patterns to handle different formats
		const patterns = [
			// Pattern 1: With ** markers
			/\*\* æ¯é€±å„€å¼ï¼š([\s\S]*?)(?=\*\*|$)/,
			// Pattern 2: Standard format
			/æ¯é€±å„€å¼[ï¼š]*([^å ´åˆ]*?)(?=å ´åˆ|$)/i,
			// Pattern 3: Direct ritual text
			/æ¯é€±å…­[^ã€‚]*ã€‚?/,
		];

		for (let pattern of patterns) {
			const match = content.match(pattern);

			if (match && match[1]) {
				return cleanContent(match[1].trim());
			} else if (match && match[0] && pattern.source.includes("æ¯é€±å…­")) {
				return cleanContent(match[0]);
			}
		}

		// Other ritual patterns
		const alternativePatterns = [
			/æ¯é€±[^ã€‚]*å…±åŒ[^ã€‚]*ã€‚/,
			/å®šæœŸ[^ã€‚]*æ´»å‹•[^ã€‚]*ã€‚/,
			/å…±åŒ[^ã€‚]*å„€å¼[^ã€‚]*ã€‚/,
		];

		for (let pattern of alternativePatterns) {
			const altMatch = content.match(pattern);
			if (altMatch) return cleanContent(altMatch[0]);
		}
		return "";
	};

	const extractSituationTable = (content) => {
		try {
			// Multiple patterns to catch different AI formats
			const patterns = [
				// Pattern 1: With ** markers
				/\*\* å ´åˆè‰²å½©æ­é…ï¼š([\s\S]*?)(?=###|$)/,
				// Pattern 2: Without ** markers
				/å ´åˆè‰²å½©æ­é…[ï¼š]*([^#]*?)(?=###|å››ã€|$)/i,
				// Pattern 3: Direct search for situation blocks
				/é‡è¦å•†å‹™å ´åˆ[ï¼š]*([^#]*?)(?=###|å››ã€|$)/i,
			];

			let tableContent = null;

			for (let pattern of patterns) {
				const match = content.match(pattern);
				if (match && match[1]) {
					tableContent = cleanContent(match[1].trim());
					break;
				}
			}

			// If we found content, parse the situations
			if (tableContent) {
				const situations = [];

				// Look for standard situation names
				const situationNames = ["é‡è¦å•†å‹™å ´åˆ", "ç¤¾äº¤èšæœƒ", "å±…å®¶ç”Ÿæ´»"];

				for (let situationName of situationNames) {
					// Extract this specific situation - fixed regex
					const situationPattern = new RegExp(
						`${situationName}[ï¼š]*([\\s\\S]*?)(?=${situationNames.filter((s) => s !== situationName).join("|")}|$)`,
						"i"
					);
					const situationMatch = tableContent.match(situationPattern);

					if (situationMatch && situationMatch[1]) {
						const situationText = cleanContent(
							situationMatch[1].trim()
						);

						// Extract male, female colors and energy function - fixed regex
						const maleMatch = situationText.match(
							/[-â€“]*\s*ç”·æ–¹[ï¼š]*([^\n]*)/
						);
						const femaleMatch = situationText.match(
							/[-â€“]*\s*å¥³æ–¹[ï¼š]*([^\n]*)/
						);
						const energyMatch = situationText.match(
							/[-â€“]*\s*èƒ½é‡ä½œç”¨[ï¼š]*([^\n]*)/
						);

						if (maleMatch && femaleMatch) {
							situations.push({
								title: situationName,
								colors: {
									male: [cleanContent(maleMatch[1].trim())],
									female: [
										cleanContent(femaleMatch[1].trim()),
									],
								},
								energyFunction: energyMatch
									? cleanContent(energyMatch[1].trim())
									: "äº”è¡Œèª¿å’Œ",
							});
						}
					}
				}

				return situations;
			}

			return [];
		} catch (error) {
			console.error("Error extracting situation table:", error);
			return [];
		}
	};

	const extractSituations = (content) => {
		const situationPatterns = [/ç´„æœƒ/g, /èšæœƒ/g, /æ—…è¡Œ/g, /å·¥ä½œ/g, /ç¤¾äº¤/g];

		const foundSituations = [];
		situationPatterns.forEach((pattern) => {
			const matches = content.match(pattern);
			if (matches) {
				matches.forEach((match) => {
					if (!foundSituations.includes(match)) {
						foundSituations.push(match);
					}
				});
			}
		});

		return foundSituations.length > 0
			? foundSituations.slice(0, 3)
			: ["é‡è¦å ´åˆ", "æ—¥å¸¸ç”Ÿæ´»", "ç‰¹æ®Šæ™‚åˆ»"];
	};

	const extractMaleColors = (content) => {
		const maleColorPattern = /ç”·æ–¹[^ï¼ˆï¼‰]*([^ã€‚]*è‰²[^ã€‚]*)/;
		const match = content.match(maleColorPattern);
		if (match) {
			const colors = match[1].match(
				/[ç´…ç¶ è—é»ƒç™½é»‘ç°æ©™ç´«ç²‰åœŸç±³è»][^ï¼Œã€‚]*/g
			);
			return colors ? colors.slice(0, 2) : null;
		}
		return null;
	};

	const extractFemaleColors = (content) => {
		const femaleColorPattern = /å¥³æ–¹[^ï¼ˆï¼‰]*([^ã€‚]*è‰²[^ã€‚]*)/;
		const match = content.match(femaleColorPattern);
		if (match) {
			const colors = match[1].match(
				/[ç´…ç¶ è—é»ƒç™½é»‘ç°æ©™ç´«ç²‰æ·ºçŠç‘š][^ï¼Œã€‚]*/g
			);
			return colors ? colors.slice(0, 2) : null;
		}
		return null;
	};

	const extractEnergyFunctions = (content) => {
		const functionPatterns = [
			/äº”è¡Œ[^ã€‚]*ç›¸ç”Ÿ[^ã€‚]*ã€‚/g,
			/èƒ½é‡[^ã€‚]*å¹³è¡¡[^ã€‚]*ã€‚/g,
			/ç›¸å‰‹[^ã€‚]*åŒ–è§£[^ã€‚]*ã€‚/g,
			/ï¼ˆ([^ï¼‰]*)ï¼‰/g, // Content in parentheses
		];

		const functions = [];
		functionPatterns.forEach((pattern) => {
			const matches = content.match(pattern);
			if (matches) {
				functions.push(...matches.slice(0, 1));
			}
		});

		return functions.length > 0
			? functions.slice(0, 3)
			: ["äº”è¡Œç›¸ç”Ÿç›¸å‰‹åŽŸç†", "èƒ½é‡å¹³è¡¡èª¿å’Œ", "å€‹æ€§åŒ–å»ºè­°æ–¹æ¡ˆ"];
	};

	// Parse energy enhancement content into structured layout matching the attached image
	const parseEnergyEnhancementContent = (content) => {
		try {
			// Extract male and female enhancement suggestions
			const maleEnhancementMatch = content.match(/ç”·æ–¹é©åˆ[^ã€‚]*ã€‚/g);
			const femaleEnhancementMatch = content.match(/å¥³æ–¹é©åˆ[^ã€‚]*ã€‚/g);

			// Extract shared activities and weekly rituals
			const weeklyRitualMatch = content.match(/æ¯æœˆ[^ã€‚]*è¾²æ›†åˆ[^ã€‚]*ã€‚/);
			const sharedActivityMatch = content.match(/å…±åŒ[^ã€‚]*ã€‚/g);

			// Extract feng shui and home arrangement suggestions
			const fengShuiMatch = content.match(
				/å±…å®¶é¢¨æ°´[^ã€‚]*ã€‚|å®¶å±…ä½ˆç½®[^ã€‚]*ã€‚|æ“ºæ”¾[^ã€‚]*ã€‚/g
			);

			// Extract lucky colors and accessories
			const luckyColorsMatch =
				content.match(/å¹´åº¦å¹¸é‹è‰²ç³»[ï¼š:]?([^ã€‚]*)/);
			const accessoriesMatch =
				content.match(/é–‹é‹ç‰©å“æŽ¨è–¦[ï¼š:]?([^ã€‚]*)/);

			// Extract energy relationship analysis
			const energyAnalysisMatch =
				content.match(/é›™æ–¹äº”è¡Œ[^ã€‚]*äº’è£œé—œä¿‚[^ã€‚]*ã€‚/);

			// Create structured energy enhancement content with enhanced helper functions
			const energyStructure = {
				title: "èƒ½é‡æå‡å»ºè­°",
				type: "energy-enhancement",
				maleSection: {
					title: "ç”·æ–¹æå‡å»ºè­°",
					actionAdvice: extractActionAdvice(content, "ç”·æ–¹"),
					accessories: extractAccessories(content, "ç”·æ–¹"),
				},
				femaleSection: {
					title: "å¥³æ–¹æå‡å»ºè­°",
					actionAdvice: extractActionAdvice(content, "å¥³æ–¹"),
					accessories: extractAccessories(content, "å¥³æ–¹"),
				},
				sharedEnhancement: {
					title: "å…±åŒèƒ½é‡å ´å¼·åŒ–",
					weeklyRitual: {
						title: "æ¯é€±å„€å¼",
						content: extractWeeklyRitual(content),
					},
					situations: extractSituationTable(content),
				},
			};

			console.log("âš¡ Energy structure created:", energyStructure);
			console.log(
				"âš¡ Male action advice:",
				energyStructure.maleSection.actionAdvice
			);
			console.log(
				"âš¡ Male accessories:",
				energyStructure.maleSection.accessories
			);
			console.log(
				"âš¡ Female action advice:",
				energyStructure.femaleSection.actionAdvice
			);
			console.log(
				"âš¡ Female accessories:",
				energyStructure.femaleSection.accessories
			);

			// Add feng shui analysis if available
			if (energyAnalysisMatch) {
				energyStructure.analysis = energyAnalysisMatch[0];
			}

			// Add extracted feng shui suggestions if available
			if (fengShuiMatch && fengShuiMatch.length > 0) {
				energyStructure.fengShuiSuggestions = fengShuiMatch;
			}

			// Add lucky colors if available
			if (luckyColorsMatch) {
				energyStructure.luckyColors = cleanContent(
					luckyColorsMatch[1].trim()
				);
			}

			return energyStructure;
		} catch (error) {
			console.error("Error parsing energy enhancement content:", error);
			return { type: "text", content: cleanContent(content) };
		}
	};

	// Parse relationship taboos content into structured layout matching the attached image
	const parseRelationshipTaboosContent = (content) => {
		try {
			// Initialize structure
			const tabooStructure = {
				type: "relationship-taboos",
				title: "æ„Ÿæƒ…é—œä¿‚ç¦å¿Œ",
				sections: [],
				monthlyNote: null,
			};

			// Split content into sections based on main headers
			const lines = content
				.split("\n")
				.filter((line) => line.trim() !== "");

			let currentSection = null;
			let currentSubsection = null;
			let collectingContent = "";

			for (let i = 0; i < lines.length; i++) {
				const line = lines[i].trim();

				// Main section headers
				if (line === "æºé€šç¦å¿Œ") {
					currentSection = {
						title: "æºé€šç¦å¿Œ",
						color: "bg-pink-600",
						subsections: [],
					};
					tabooStructure.sections.push(currentSection);
					continue;
				}

				if (line === "è¡Œç‚ºç¦å¿Œ") {
					currentSection = {
						title: "è¡Œç‚ºç¦å¿Œ",
						color: "bg-red-600",
						subsections: [],
					};
					tabooStructure.sections.push(currentSection);
					continue;
				}

				if (line === "ç’°å¢ƒç¦å¿Œ") {
					currentSection = {
						title: "ç’°å¢ƒç¦å¿Œ",
						color: "bg-red-800",
						subsections: [],
					};
					tabooStructure.sections.push(currentSection);
					continue;
				}

				// Handle monthly note
				if (line.startsWith("æ¯æœˆåˆ")) {
					tabooStructure.monthlyNote = {
						title: "æ¯æœˆåˆ",
						content: cleanContent(line),
					};
					continue;
				}

				// Subsection headers and content
				if (currentSection) {
					// Check if this is a subsection header
					if (
						line === "å¥³æ–¹å¿Œç”¨" ||
						line === "ç”·æ–¹å¿Œç”¨" ||
						line === "æ˜¥å­£" ||
						line === "å¤å­£" ||
						line === "æˆŠæœˆ" ||
						line === "ç´„æœƒé¿é–‹" ||
						line === "åŒæˆ¿ç¦å¿Œ"
					) {
						// Save previous subsection if exists
						if (currentSubsection && collectingContent.trim()) {
							currentSubsection.content =
								collectingContent.trim();
							collectingContent = "";
						}

						// Start new subsection
						currentSubsection = {
							title: line,
							content: "",
						};
						currentSection.subsections.push(currentSubsection);
					} else if (currentSubsection && line !== "") {
						// Collect content for current subsection
						if (collectingContent) {
							collectingContent += " ";
						}
						collectingContent += line;
					}
				}
			}

			// Handle last subsection
			if (currentSubsection && collectingContent.trim()) {
				currentSubsection.content = collectingContent.trim();
			}

			// Fallback to hardcoded structure if parsing fails or is incomplete
			if (tabooStructure.sections.length === 0) {
				tabooStructure.sections = [
					{
						title: "æºé€šç¦å¿Œ",
						color: "bg-pink-600",
						subsections: [
							{
								title: "å¥³æ–¹å¿Œç”¨",
								content:
									"ã€Œä½ ç¸½æ˜¯â€¦ã€ã€Œç‚ºä»€éº¼ä¸â€¦ã€ï¼ˆé»ƒæœ¨é£Ÿç¥žå—å‰‹æ˜“å¼•çˆ†æƒ…ç·’ï¼‰",
							},
							{
								title: "ç”·æ–¹å¿Œç”¨",
								content:
									"ã€Œéš¨ä¾¿ã€ã€Œä»¥å¾Œå†èªªã€ï¼ˆå­æ°´ä¸ƒæ®ºéŽé‡æ‹–å»¶å¼·åŒ–å†·æš´åŠ›ï¼‰",
							},
						],
					},
					{
						title: "è¡Œç‚ºç¦å¿Œ",
						color: "bg-red-600",
						subsections: [
							{
								title: "æ˜¥å­£",
								content:
									"é¿å…åœ¨ç”³æ™‚ï¼ˆ15-17æ™‚ï¼‰è¨Žè«–æ•æ„Ÿè©±é¡Œï¼Œå› æ­¤æ™‚é‡‘æ°£æ—ºç››æ˜“å¼•ç™¼çˆ­åŸ·",
							},
							{
								title: "å¤å­£",
								content:
									"å¿Œåœ¨è‡¥å®¤è¥¿åŒ—æ–¹æ”¾ç½®å°–éŠ³ç‰©å“ï¼Œé˜²æ­¢é‡‘æœ¨ç›¸å‰‹å½±éŸ¿æ„Ÿæƒ…",
							},
							{
								title: "æˆŠæœˆ",
								content:
									"2025å¹´è¾²æ›†ä¹æœˆéœ€ç‰¹åˆ¥æ³¨æ„è²¡å‹™è¦åŠƒï¼Œé¿å…å› é‡‘éŒ¢å•é¡Œç”¢ç”Ÿéš”é–¡",
							},
						],
					},
					{
						title: "ç’°å¢ƒç¦å¿Œ",
						color: "bg-red-800",
						subsections: [
							{
								title: "ç´„æœƒé¿é–‹",
								content:
									"ç´„æœƒé¿é–‹ï¼šç«é‹åº—ï¼ˆç«æ°£éŽé‡ï¼‰ã€åœ°ä¸‹å®¤ï¼ˆæ°´æ°£æ»¯æ²‰ï¼‰",
							},
							{
								title: "åŒæˆ¿ç¦å¿Œ",
								content:
									"å­æ™‚ï¼ˆ23-1é»žï¼‰å®œç ‚ï¼Œæ˜“æˆå¿ƒçµï¼›å¯æ”¹ç‚ºå‚™å¿˜éŒ„æ¬¡æ—¥å†è­°",
							},
						],
					},
				];
			}

			if (!tabooStructure.monthlyNote) {
				tabooStructure.monthlyNote = {
					title: "æ¯æœˆåˆ",
					content:
						"åŒ–è§£æ–¹æ³•ï¼šåœ¨å®¢å»³æ±å—æ–¹æ‡¸æŽ›ç‰¡ä¸¹åœ–ï¼ˆæœ¨ç«ç›¸ç”Ÿï¼‰ï¼Œå…±åŒä½©æˆ´é´›é´¦çŽ‰ä½©å¢žå¼·ç·£åˆ†",
				};
			}

			return tabooStructure;
		} catch (error) {
			console.error("Error parsing relationship taboos content:", error);
			return { type: "text", content: content };
		}
	};
	const extractCommunicationPattern = (content, pattern) => {
		try {
			const regex = new RegExp(`([^ã€‚]*(?:${pattern})[^ã€‚]*ã€‚?)`, "gi");
			const matches = content.match(regex);
			if (matches && matches.length > 0) {
				// Return full content without arbitrary truncation
				return matches[0].trim();
			}
			return null;
		} catch (error) {
			return null;
		}
	};

	// Parse relationship development content into structured subsections
	const parseRelationshipDevelopmentContent = (content) => {
		try {
			// Clean content first to remove markdown and convert to traditional Chinese
			const cleanedContent = cleanContent(content);

			// Extract main analysis content using both simplified and traditional patterns
			const analysisMatch = cleanedContent.match(
				/(?:å…·ä½“åˆ†æž|å…·é«”åˆ†æž)[ï¼š:]?([\s\S]*?)(?=(?:è¡ŒåŠ¨å»ºè®®|è¡Œå‹•å»ºè­°|æ—¶æœºä¸Žæ–¹æ³•|æ™‚æ©Ÿèˆ‡æ–¹æ³•|æ³¨æ„äº‹é¡¹|æ³¨æ„äº‹é …)|$)/
			);
			const actionMatch = cleanedContent.match(
				/(?:è¡ŒåŠ¨å»ºè®®|è¡Œå‹•å»ºè­°)[ï¼š:]?([\s\S]*?)(?=(?:æ—¶æœºä¸Žæ–¹æ³•|æ™‚æ©Ÿèˆ‡æ–¹æ³•|æ³¨æ„äº‹é¡¹|æ³¨æ„äº‹é …)|$)/
			);
			const timingMatch = cleanedContent.match(
				/(?:æ—¶æœºä¸Žæ–¹æ³•|æ™‚æ©Ÿèˆ‡æ–¹æ³•)[ï¼š:]?([\s\S]*?)(?=(?:æ³¨æ„äº‹é¡¹|æ³¨æ„äº‹é …)|$)/
			);
			const noteMatch = cleanedContent.match(
				/(?:æ³¨æ„äº‹é¡¹|æ³¨æ„äº‹é …)[ï¼š:]?([\s\S]*?)$/
			);

			// Structure the content into seasonal recommendations - content already cleaned
			const structuredContent = {
				analysis: analysisMatch ? analysisMatch[1].trim() : "",
				actions: actionMatch ? actionMatch[1].trim() : "",
				timing: timingMatch ? timingMatch[1].trim() : "",
				notes: noteMatch ? noteMatch[1].trim() : "",
			};

			// Create subsections based on the actual content patterns
			const subsections = [];

			// Extract action advice (è¡Œå‹•å»ºè­° / è¡ŒåŠ¨å»ºè®®) - highest priority
			const actionPattern =
				/(?:è¡Œå‹•å»ºè­°|è¡ŒåŠ¨å»ºè®®)[ï¼š:]?([\s\S]*?)(?=æ™‚æ©Ÿèˆ‡æ–¹æ³•|æ—¶æœºä¸Žæ–¹æ³•|æ³¨æ„äº‹é …|æ³¨æ„äº‹é¡¹|å…·ä½“åˆ†æž|å…·é«”åˆ†æž|###|$)/i;
			const actionContentMatch = content.match(actionPattern);
			if (actionContentMatch && actionContentMatch[1]) {
				const actionContent = cleanContent(
					actionContentMatch[1].trim()
				);
				if (actionContent.length > 20) {
					subsections.push({
						title: t("subsections.actionAdvice"),
						color: "bg-yellow-500",
						content: actionContent,
					});
				}
			}

			// Extract timing content (æ™‚æ©Ÿèˆ‡æ–¹æ³• / æ—¶æœºä¸Žæ–¹æ³•) - second priority
			const timingPattern =
				/(?:æ™‚æ©Ÿèˆ‡æ–¹æ³•|æ—¶æœºä¸Žæ–¹æ³•)[ï¼š:]?([\s\S]*?)(?=æ³¨æ„äº‹é …|æ³¨æ„äº‹é¡¹|è¡Œå‹•å»ºè­°|è¡ŒåŠ¨å»ºè®®|å…·ä½“åˆ†æž|å…·é«”åˆ†æž|###|$)/i;
			const timingContentMatch = content.match(timingPattern);
			if (timingContentMatch && timingContentMatch[1]) {
				const timingContent = cleanContent(
					timingContentMatch[1].trim()
				);
				if (timingContent.length > 20) {
					subsections.push({
						title: t("subsections.bestTiming"),
						color: "bg-yellow-500",
						content: timingContent,
					});
				}
			}

			// Extract precautions (æ³¨æ„äº‹é … / æ³¨æ„äº‹é¡¹) - third priority
			const notesPattern =
				/(?:æ³¨æ„äº‹é …|æ³¨æ„äº‹é¡¹)[ï¼š:]?([\s\S]*?)(?=è¡Œå‹•å»ºè­°|è¡ŒåŠ¨å»ºè®®|æ™‚æ©Ÿèˆ‡æ–¹æ³•|æ—¶æœºä¸Žæ–¹æ³•|å…·ä½“åˆ†æž|å…·é«”åˆ†æž|###|$)/i;
			const notesContentMatch = content.match(notesPattern);
			if (notesContentMatch && notesContentMatch[1]) {
				const notesContent = cleanContent(notesContentMatch[1].trim());
				if (notesContent.length > 20) {
					subsections.push({
						title: t("subsections.precautions"),
						color: "bg-yellow-500",
						content: notesContent,
					});
				}
			} // Only use analysis content if we have fewer than 2 sections
			if (subsections.length < 2) {
				const analysisPattern =
					/(?:å…·ä½“åˆ†æž|å…·é«”åˆ†æž)[ï¼š:]?([\s\S]*?)(?=è¡Œå‹•å»ºè­°|è¡ŒåŠ¨å»ºè®®|æ™‚æ©Ÿèˆ‡æ–¹æ³•|æ—¶æœºä¸Žæ–¹æ³•|æ³¨æ„äº‹é …|æ³¨æ„äº‹é¡¹|###|$)/i;
				const analysisContentMatch = content.match(analysisPattern);
				if (analysisContentMatch && analysisContentMatch[1]) {
					let analysisContent = analysisContentMatch[1].trim();

					// Only include if it contains actionable elements, not just technical analysis
					if (
						/å»ºè­°|æ–¹æ³•|æ™‚æ©Ÿ|æ³¨æ„|é¿å…|é©åˆ|å®œ|æ‡‰è©²/.test(
							analysisContent
						)
					) {
						// Extract only the practical guidance sentences
						const practicalSentences = analysisContent
							.split(/[ã€‚ï¼ï¼Ÿ]/)
							.filter((sentence) =>
								/å»ºè­°|æ–¹æ³•|æ™‚æ©Ÿ|æ³¨æ„|é¿å…|é©åˆ|å®œ|æ‡‰è©²|æœ€ä½³/.test(
									sentence
								)
							)
							.map((sentence) => sentence.trim() + "ã€‚")
							.join("");

						if (practicalSentences.length > 20) {
							subsections.push({
								title: t("subsections.destinyGuidance"),
								color: "bg-yellow-500",
								content: cleanContent(practicalSentences),
							});
						}
					}
				}
			} // If no specific seasonal content found, create general subsections from the structured content
			if (subsections.length === 0) {
				subsections.push(
					{
						title: t("subsections.actionAdvice"),
						color: "bg-yellow-500",
						content:
							structuredContent.actions ||
							"é¿å…é‡å¤§é—œä¿‚æ±ºç­–ï¼ˆå¦‚åŒå±…ã€è³¼æˆ¿ï¼‰ï¼Œå„ªå…ˆç¶“ç‡Ÿæ—¥å¸¸æº«æƒ…ã€‚",
					},
					{
						title: t("subsections.bestTiming"),
						color: "bg-yellow-500",
						content:
							structuredContent.timing ||
							"æ¯æœˆå®‰æŽ’ä¸€æ¬¡ã€Œç„¡ç›®çš„ç´„æœƒã€ï¼ˆå¦‚æ·±å¤œæ•£æ­¥ã€çœ‹æ˜Ÿæ˜Ÿï¼‰ï¼Œè„«é›¢ç¾å¯¦å£“åŠ›å ´æ™¯ã€‚",
					},
					{
						title: t("subsections.precautions"),
						color: "bg-yellow-500",
						content:
							structuredContent.notes ||
							"ç”·æ–¹ä¸»å‹•ç­–åŠƒé©šå–œï¼ˆä¸ç«éœ€æœ¨ç«æ¿€ç™¼ç†±æƒ…ï¼‰ï¼Œä¾‹å¦‚è¦ªæ‰‹è£½ä½œç¦®ç‰©ã€‚",
					}
				);
			}

			return { type: "subsections", subsections };
		} catch (error) {
			console.error(
				"Error parsing relationship development content:",
				error
			);
			// Fallback to simple text
			return { type: "text", content: content };
		}
	};

	// Extract seasonal content from the full text
	const extractSeasonalContent = (fullContent, seasonPattern) => {
		try {
			// First try to find complete sentences with seasonal keywords
			const sentenceRegex = new RegExp(
				`([^ã€‚ï¼ï¼Ÿ]*(?:${seasonPattern})[^ã€‚ï¼ï¼Ÿ]*[ã€‚ï¼ï¼Ÿ])`,
				"gi"
			);
			const sentenceMatches = fullContent.match(sentenceRegex);

			if (sentenceMatches && sentenceMatches.length > 0) {
				// Join the first 2-3 relevant sentences and allow full content
				const relevantSentences = sentenceMatches.slice(0, 3).join("");
				// Clean the content before returning
				return cleanContent(relevantSentences);
			}

			// Fallback: find any mention with broader context
			const contextRegex = new RegExp(
				`([^ã€‚]{0,50}(?:${seasonPattern})[^ã€‚]{0,50})`,
				"gi"
			);
			const contextMatches = fullContent.match(contextRegex);

			if (contextMatches && contextMatches.length > 0) {
				return cleanContent(contextMatches[0].trim() + "ã€‚");
			}

			return null;
		} catch (error) {
			console.error("Error extracting seasonal content:", error);
			return null;
		}
	};

	// Clean and structure the extracted content
	const cleanAndStructureContent = (content) => {
		// Remove formatting markers and clean up
		let cleanedContent = content
			.replace(/^[ï¼š:]\s*/, "")
			.replace(/ã€[^ã€‘]*ã€‘/g, "")
			.replace(/####/g, "")
			.replace(/\n\s*\n/g, "\n")
			.trim();

		// Apply our new cleaning functions
		cleanedContent = cleanContent(cleanedContent);

		// Return full content without truncation for complete AI analysis
		return cleanedContent;
	};

	// Extract motto from AI content
	const extractCoupleMottoFromContent = (content) => {
		// Try to find motto-like statements for couples
		const mottoPatterns = [
			/å¤«å¦»ç®´è¨€[ï¼š:]([^ã€‚\n]*)/,
			/æ„Ÿæƒ…æ ¸å¿ƒ[ï¼š:]([^ã€‚\n]*)/,
			/é—œä¿‚è¦è¨£[ï¼š:]([^ã€‚\n]*)/,
		];

		for (let pattern of mottoPatterns) {
			const match = content.match(pattern);
			if (match && match[1]) {
				return match[1].trim();
			}
		}

		// Fallback motto for couples
		return "å¤«å¦»åŒå¿ƒï¼Œå…¶åˆ©æ–·é‡‘ã€‚ç›¸äº’ç†è§£ï¼Œå½¼æ­¤åŒ…å®¹ï¼Œæ„›æƒ…é•·ä¹…ã€‚";
	};

	// Get fallback content for each category
	const getFallbackCategoryContent = (categoryTitle) => {
		const fallbackContent = {
			é—œä¿‚ç™¼å±•å»ºè­°:
				"æ ¹æ“šå¤«å¦»é›™æ–¹å…«å­—åˆç›¤åˆ†æžï¼Œå»ºè­°åœ¨æ˜¥å­£åŠ å¼·æºé€šï¼Œå¤å­£æ³¨æ„æƒ…ç·’ç®¡ç†ï¼Œç§‹å­£æ·±åŒ–æ„Ÿæƒ…ï¼Œå†¬å­£è¦åŠƒæœªä¾†ã€‚é‡é»žæŠŠæ¡é—œéµæ™‚é–“ç¯€é»žï¼Œé¿å…åœ¨ä¸åˆ©æ™‚æœŸåšé‡å¤§æ±ºå®šã€‚",
			æºé€šå»ºè­°:
				"å¤«å¦»æºé€šéœ€è¦æ ¹æ“šé›™æ–¹æ€§æ ¼ç‰¹é»žèª¿æ•´æ–¹å¼ã€‚å»ºè­°é¸æ“‡åˆé©çš„æ™‚é–“å’Œåœ°é»žï¼Œç”¨æº«å’Œçš„èªžæ°£è¡¨é”æƒ³æ³•ï¼Œå¤šè†è½å°æ–¹è§€é»žï¼Œé¿å…åœ¨æƒ…ç·’æ¿€å‹•æ™‚è¨Žè«–é‡è¦å•é¡Œã€‚",
			èƒ½é‡æå‡å»ºè­°:
				"é€šéŽäº”è¡Œèª¿å’Œæå‡å¤«å¦»æ„Ÿæƒ…èƒ½é‡ã€‚å»ºè­°ä½©æˆ´é©åˆçš„é£¾å“ï¼Œèª¿æ•´å±…å®¶ç’°å¢ƒï¼Œé¸æ“‡æœ‰åˆ©çš„æ´»å‹•æ™‚é–“ï¼Œå…±åŒé€²è¡Œèƒ½é‡æå‡çš„æ´»å‹•ã€‚",
			æ„Ÿæƒ…é—œä¿‚ç¦å¿Œ: parseRelationshipTaboosContent(`æ„Ÿæƒ…é—œä¿‚ç¦å¿Œ
æºé€šç¦å¿Œ
å¥³æ–¹å¿Œç”¨
ã€Œä½ ç¸½æ˜¯â€¦ã€ã€Œç‚ºä»€éº¼ä¸â€¦ã€ï¼ˆé»ƒæœ¨é£Ÿç¥žå—å‰‹æ˜“å¼•çˆ†æƒ…ç·’ï¼‰

ç”·æ–¹å¿Œç”¨
ã€Œéš¨ä¾¿ã€ã€Œä»¥å¾Œå†èªªã€ï¼ˆå­æ°´ä¸ƒæ®ºéŽé‡æ‹–å»¶å¼·åŒ–å†·æš´åŠ›ï¼‰

è¡Œç‚ºç¦å¿Œ
æ˜¥å­£
é¿å…åœ¨ç”³æ™‚ï¼ˆ15-17æ™‚ï¼‰è¨Žè«–æ•æ„Ÿè©±é¡Œï¼Œå› æ­¤æ™‚é‡‘æ°£æ—ºç››æ˜“å¼•ç™¼çˆ­åŸ·

å¤å­£
å¿Œåœ¨è‡¥å®¤è¥¿åŒ—æ–¹æ”¾ç½®å°–éŠ³ç‰©å“ï¼Œé˜²æ­¢é‡‘æœ¨ç›¸å‰‹å½±éŸ¿æ„Ÿæƒ…

æˆŠæœˆ
2025å¹´è¾²æ›†ä¹æœˆéœ€ç‰¹åˆ¥æ³¨æ„è²¡å‹™è¦åŠƒï¼Œé¿å…å› é‡‘éŒ¢å•é¡Œç”¢ç”Ÿéš”é–¡

ç’°å¢ƒç¦å¿Œ
ç´„æœƒé¿é–‹
ç´„æœƒé¿é–‹ï¼šç«é‹åº—ï¼ˆç«æ°£éŽé‡ï¼‰ã€åœ°ä¸‹å®¤ï¼ˆæ°´æ°£æ»¯æ²‰ï¼‰

åŒæˆ¿ç¦å¿Œ
å­æ™‚ï¼ˆ23-1é»žï¼‰å®œç ‚ï¼Œæ˜“æˆå¿ƒçµï¼›å¯æ”¹ç‚ºå‚™å¿˜éŒ„æ¬¡æ—¥å†è­°

æ¯æœˆåˆ
åŒ–è§£æ–¹æ³•ï¼šåœ¨å®¢å»³æ±å—æ–¹æ‡¸æŽ›ç‰¡ä¸¹åœ–ï¼ˆæœ¨ç«ç›¸ç”Ÿï¼‰ï¼Œå…±åŒä½©æˆ´é´›é´¦çŽ‰ä½©å¢žå¼·ç·£åˆ†`),
		};
		return fallbackContent[categoryTitle] || "æ­£åœ¨ç‚ºæ‚¨åˆ†æžå¤«å¦»é—œä¿‚å»ºè­°...";
	};

	// Minimal fallback when AI completely fails
	const getCoupleFallbackComponentData = (year, user1, user2) => {
		console.log(
			"ðŸš¨ FALLBACK TRIGGERED: Using fallback couple component data"
		);
		console.log("ðŸš¨ Fallback reasons: API failed or returned invalid data");

		return {
			title: "å¤«å¦»é–‹é‹å»ºè­°",
			subtitle: `${user1?.name || "ç”·æ–¹"} & ${user2?.name || "å¥³æ–¹"} æ„Ÿæƒ…æŒ‡å—`,
			coreIcon: "ðŸ’•",
			iconColor: "bg-[#B4003C]",
			coreTitle: "å¤«å¦»å’Œè«§",
			coreIconList: [
				{
					icon: "/images/report/star.png",
					label: "é—œä¿‚ç™¼å±•å»ºè­°",
					color: "bg-[#DEAB20]",
					active: true,
				},
				{
					icon: "/images/report/chat.png",
					label: "æºé€šå»ºè­°",
					color: "bg-[#8A71C7]",
					active: false,
				},
				{
					icon: "/images/report/fengshui.png",
					label: "èƒ½é‡æå‡å»ºè­°",
					color: "bg-[#8FA940]",
					active: false,
				},
				{
					icon: "/images/report/warning.png",
					label: "æ„Ÿæƒ…é—œä¿‚ç¦å¿Œ",
					color: "bg-[#B4003C]",
					active: false,
				},
			],
			coreCategories: [
				{
					title: "é—œä¿‚ç™¼å±•å»ºè­°",
					subtitle: "ç­‰å¾…AIåˆ†æž",
					icon: "/images/report/star.png",
					color: "bg-[#DEAB20]",
					content: "æ­£åœ¨ç‚ºæ‚¨ç”Ÿæˆå€‹äººåŒ–çš„å¤«å¦»é—œä¿‚ç™¼å±•å»ºè­°ï¼Œè«‹ç¨å€™...",
				},
				{
					title: "æºé€šå»ºè­°",
					subtitle: "ç­‰å¾…AIåˆ†æž",
					icon: "/images/report/chat.png",
					color: "bg-[#8A71C7]",
					content: "æ­£åœ¨ç‚ºæ‚¨ç”Ÿæˆå€‹äººåŒ–çš„å¤«å¦»æºé€šå»ºè­°ï¼Œè«‹ç¨å€™...",
				},
				{
					title: "èƒ½é‡æå‡å»ºè­°",
					subtitle: "ç­‰å¾…AIåˆ†æž",
					icon: "/images/report/fengshui.png",
					color: "bg-[#8FA940]",
					content: "æ­£åœ¨ç‚ºæ‚¨ç”Ÿæˆå€‹äººåŒ–çš„å¤«å¦»èƒ½é‡æå‡å»ºè­°ï¼Œè«‹ç¨å€™...",
				},
				{
					title: "æ„Ÿæƒ…é—œä¿‚ç¦å¿Œ",
					subtitle: "ç­‰å¾…AIåˆ†æž",
					icon: "/images/report/warning.png",
					color: "bg-[#B4003C]",
					content: "æ­£åœ¨ç‚ºæ‚¨ç”Ÿæˆå€‹äººåŒ–çš„å¤«å¦»ç›¸è™•ç¦å¿Œï¼Œè«‹ç¨å€™...",
				},
			],
			motto: "å¤«å¦»åŒå¿ƒï¼Œå…¶åˆ©æ–·é‡‘ã€‚ç›¸äº’ç†è§£ï¼Œå½¼æ­¤åŒ…å®¹ï¼Œæ„›æƒ…é•·ä¹…ã€‚",
			coreStrategy: "å¤«å¦»å…«å­—åˆç›¤ï¼Œäº”è¡Œèª¿å’Œï¼Œæ„Ÿæƒ…é•·ä¹…",
			year,
			concern: "æ„Ÿæƒ…",
			user1Birthday: user1?.birthDateTime || "",
			user2Birthday: user2?.birthDateTime || "",
			user1Name: user1?.name || "ç”·æ–¹",
			user2Name: user2?.name || "å¥³æ–¹",
			error: "AIåˆ†æžæœå‹™æš«æ™‚ä¸å¯ç”¨ï¼Œç³»çµ±æ­£åœ¨å˜—è©¦é‡æ–°é€£ç·šã€‚",
		};
	};

	// Create cache key for couple core suggestion analysis with more specificity
	const getCacheKey = (user1, user2, year) => {
		const user1Date = user1.birthDateTime || user1.birthday;
		const user2Date = user2.birthDateTime || user2.birthday;
		const concern = "æ„Ÿæƒ…"; // Default concern for couple core suggestion analysis
		// Use stable cache key for normal caching behavior
		return `couple_core_suggestion_${user1Date}_${user2Date}_${concern}_${year}`;
	};

	useEffect(() => {
		if (!user1 || !user2) return;

		// Check for historical saved data first (highest priority)
		const historicalData = getCoupleComponentData("coupleCoreSuggestion");
		if (historicalData) {
			console.log(
				"ðŸ›ï¸ Using historical couple core suggestion data from data store"
			);
			setAnalysisData(historicalData);
			setIsLoading(false);
			return;
		}

		const cacheKey = getCacheKey(user1, user2, currentYear);
		console.log("ðŸ”‘ CoupleCoreSuggestion cache key:", cacheKey);
		console.log("ðŸ” Current birth dates:", {
			user1: user1.birthDateTime,
			user2: user2.birthDateTime,
		});

		// Check cache first
		if (coupleCoreSuggestionCache && coupleCoreSuggestionCache[cacheKey]) {
			console.log("ðŸ“‹ Using cached couple core suggestion analysis");
			setAnalysisData(coupleCoreSuggestionCache[cacheKey]);
			setIsLoading(false);
			return;
		}

		console.log("ðŸš€ Generating fresh couple core suggestion analysis...");
		setIsLoading(true);
		setError(null);

		// Generate new analysis
		generateCoupleCoreSuggestionAnalysis(user1, user2, currentYear)
			.then((analysis) => {
				setAnalysisData(analysis);

				// Cache the result
				setCoupleCoreSuggestionCache((prevCache) => ({
					...prevCache,
					[cacheKey]: analysis,
				}));

				// Save to database immediately
				const sessionId =
					`couple_${user1.birthDateTime}_${user2.birthDateTime}`.replace(
						/[^a-zA-Z0-9]/g,
						"_"
					);
				saveComponentContentWithUser(
					session,
					sessionId,
					"coupleCoreSuggestion",
					analysis,
					{
						birthday: user1.birthDateTime,
						birthday2: user2.birthDateTime,
						gender: user1.gender,
						gender2: user2.gender,
					}
				);
			})
			.catch((error) => {
				console.error("Couple core suggestion analysis failed:", error);
				setError(error.message);

				// Set minimal fallback
				const fallback = getCoupleFallbackComponentData(
					currentYear,
					user1,
					user2
				);
				setAnalysisData(fallback);
			})
			.finally(() => {
				setIsLoading(false);
			});
	}, [
		user1?.birthDateTime,
		user2?.birthDateTime,
		user1?.birthday,
		user2?.birthday,
		currentYear,
	]);

	if (isLoading) {
		return (
			<section
				className="relative mx-auto mb-4 bg-white sm:mb-6 lg:mb-10"
				style={{
					width: "100%",
					padding: "clamp(16px, 4vw, 40px)",
					boxShadow: "0 4px 4px rgba(0, 0, 0, 0.25)",
					borderRadius: "clamp(20px, 5vw, 45px)",
				}}
			>
				<div className="flex flex-col items-center justify-center py-12 space-y-4">
					{/* Loading spinner */}
					<div className="w-8 h-8 border-b-2 border-pink-500 rounded-full animate-spin"></div>

					{/* é¢¨éˆ´ loading image */}
					<div className="flex items-center justify-center">
						<Image
							src="/images/é¢¨æ°´å¦¹/é¢¨æ°´å¦¹-loading.png"
							alt={t("loadingAlt")}
							width={120}
							height={120}
							className="object-contain"
						/>
					</div>

					{/* Loading text */}
					<div className="space-y-2 text-center">
						<div
							className="text-gray-700"
							style={{
								fontFamily: "Noto Sans HK, sans-serif",
								fontSize: "clamp(0.875rem, 2.5vw, 1rem)",
								fontWeight: 500,
							}}
						>
							{t("loadingTitle")}
						</div>
						<div
							className="text-gray-500"
							style={{
								fontFamily: "Noto Sans HK, sans-serif",
								fontSize: "clamp(0.75rem, 2vw, 0.875rem)",
								fontWeight: 400,
							}}
						>
							{t("loadingSubtitle")}
						</div>
					</div>
				</div>
			</section>
		);
	}

	if (!analysisData) {
		return (
			<section
				className="relative mx-auto mb-4 bg-white sm:mb-6 lg:mb-10"
				style={{
					width: "100%",
					padding: "clamp(16px, 4vw, 40px)",
					boxShadow: "0 4px 4px rgba(0, 0, 0, 0.25)",
					borderRadius: "clamp(20px, 5vw, 45px)",
				}}
			>
				<div
					className="py-6 text-center text-gray-500 sm:py-8"
					style={{ fontSize: "clamp(14px, 3.5vw, 16px)" }}
				>
					{t("noData")}
				</div>
			</section>
		);
	}

	const activeCategory = analysisData.coreCategories[activeCategoryIndex];

	return (
		<ComponentErrorBoundary componentName="CoupleCoreSuggestion">
			<section
				className="relative mx-auto mb-4 bg-white sm:mb-6 lg:mb-10"
				style={{
					width: "100%",
					padding: "clamp(16px, 4vw, 40px)",
					boxShadow: "0 4px 4px rgba(0, 0, 0, 0.25)",
					borderRadius: "clamp(20px, 5vw, 45px)",
				}}
			>
				{/* Header */}
				<div className="flex items-center justify-center mb-6 sm:mb-8">
					<h2
						style={{
							fontFamily: "Noto Serif TC, serif",
							fontSize: "clamp(28px, 7vw, 40px)",
							fontWeight: 800,
							color: "#B4003C", // Couple theme color
						}}
					>
						{t("title")}
					</h2>
				</div>

				{/* Couple Info Banner */}
				{/* <div className="p-4 mb-8 border border-pink-200 rounded-lg bg-gradient-to-r from-pink-50 to-red-50">
					<div className="flex items-center justify-center text-center">
						<span className="text-lg font-medium text-gray-700">
							{analysisData.user1Name} & {analysisData.user2Name}
						</span>
						<span className="mx-3 text-pink-500">ðŸ’•</span>
						<span className="text-sm text-gray-600">
							å¤«å¦»åˆç›¤é–‹é‹æŒ‡å—
						</span>
					</div>
				</div>
 */}
				{/* Error Message */}
				{analysisData?.error && (
					<div className="p-3 mb-6 bg-yellow-100 border border-yellow-400 rounded-lg">
						<p className="text-sm text-yellow-700">
							âš ï¸ {analysisData.error}
						</p>
					</div>
				)}

				{/* Core Icons Section */}
				<div
					className="mb-6 bg-white sm:mb-8"
					style={{ padding: "clamp(16px, 4vw, 24px)" }}
				>
					<div className="grid w-full grid-cols-2 gap-4 mb-4 sm:flex sm:items-center sm:justify-between sm:mb-6">
						{analysisData.coreIconList.map((item, index) => {
							const getButtonBgColor = (
								categoryIndex,
								isActive
							) => {
								const colors = [
									"bg-[#DEAB20]", // Relationship
									"bg-[#8A71C7]", // Communication
									"bg-[#8FA940]", // Energy
									"bg-[#B4003C]", // Taboos
								];
								return isActive
									? colors[categoryIndex]
									: "bg-white";
							};

							const getItemImage = (categoryIndex) => {
								const images = [
									"/images/report/star.png", // Relationship
									"/images/report/chat.png", // Communication
									"/images/report/fengshui.png", // Energy
									"/images/report/warning.png", // Taboos
								];
								return (
									images[categoryIndex] ||
									"/images/report/heart.png"
								);
							};

							const getImageFilter = (isActive) => {
								return isActive
									? "brightness(0) invert(1)"
									: "none";
							};

							return (
								<button
									key={index}
									onClick={() =>
										setActiveCategoryIndex(index)
									}
									className={`flex flex-col items-center transition-all duration-300 sm:flex-1 ${
										activeCategoryIndex === index
											? "transform scale-105 sm:scale-110"
											: "hover:scale-105"
									}`}
									style={{ gap: "clamp(4px, 1vw, 8px)" }}
								>
									<div
										className={`rounded-full flex items-center justify-center text-white transition-all duration-300 ${getButtonBgColor(
											index,
											activeCategoryIndex === index
										)}`}
										style={{
											width: "clamp(48px, 12vw, 64px)",
											height: "clamp(48px, 12vw, 64px)",
											boxShadow:
												"0 4px 4px rgba(0, 0, 0, 0.25)",
										}}
									>
										<img
											src={getItemImage(index)}
											alt={item.label}
											style={{
												width: "clamp(24px, 6vw, 32px)",
												height: "clamp(24px, 6vw, 32px)",
												filter: getImageFilter(
													activeCategoryIndex ===
														index
												),
											}}
										/>
									</div>
									<span
										className={`font-medium text-center ${
											activeCategoryIndex === index
												? "text-gray-800"
												: "text-gray-500"
										}`}
										style={{
											fontSize:
												"clamp(11px, 2.5vw, 14px)",
											lineHeight: "1.2",
										}}
									>
										{item.label}
									</span>
								</button>
							);
						})}
					</div>
					{/* Active Category Title */}
					<div className="text-center">
						<h3
							style={{
								fontFamily: "Noto Serif TC, serif",
								fontSize: "clamp(24px, 6vw, 40px)",
								fontWeight: 700,
								color: (() => {
									const titleColors = [
										"#DEAB20",
										"#8A71C7",
										"#8FA940",
										"#B4003C",
									];
									return (
										titleColors[activeCategoryIndex] ||
										"#B4003C"
									);
								})(),
								marginBottom: "clamp(6px, 2vw, 8px)",
							}}
						>
							{activeCategory.title}
						</h3>
					</div>{" "}
					{/* Content Display */}
					<div className="mt-6 sm:mt-8">
						<div style={{ padding: "clamp(16px, 4vw, 24px)" }}>
							<div className="space-y-3 sm:space-y-4">
								{/* Check content type and render accordingly */}
								{typeof activeCategory.content === "object" &&
								activeCategory.content.type ===
									"subsections" ? (
									/* Relationship Development Subsections */
									<div className="space-y-4 sm:space-y-6">
										{activeCategory.content.subsections.map(
											(subsection, index) => (
												<div
													key={index}
													className="overflow-hidden border border-[#EFEFEF] shadow-lg"
													style={{
														borderRadius:
															"clamp(8px, 2vw, 12px)",
													}}
												>
													{/* Subsection Header */}
													<div
														className={`${subsection.color} text-white font-medium text-center`}
														style={{
															padding:
																"clamp(8px, 2vw, 16px) clamp(12px, 3vw, 16px)",
															fontSize:
																"clamp(14px, 3.5vw, 16px)",
															borderRadius:
																"clamp(8px, 2vw, 12px) clamp(8px, 2vw, 12px) 0 0",
														}}
													>
														{subsection.title}
													</div>
													{/* Subsection Content */}
													<div
														className="bg-[#EFEFEF]"
														style={{
															padding:
																"clamp(12px, 3vw, 16px)",
														}}
													>
														<p
															className="leading-relaxed text-gray-700"
															style={{
																fontSize:
																	"clamp(13px, 3.2vw, 15px)",
															}}
														>
															{subsection.content}
														</p>
													</div>
												</div>
											)
										)}
									</div>
								) : typeof activeCategory.content ===
										"object" &&
								  activeCategory.content.type ===
										"communication-structure" ? (
									/* Communication Advice Structure */
									<div className="space-y-4 sm:space-y-6">
										{activeCategory.content.sections.map(
											(section, sectionIndex) => (
												<div key={sectionIndex}>
													{section.type ===
													"partner-styles" ? (
														/* Partner Communication Styles */
														<div className="space-y-3 sm:space-y-4">
															<h4
																className="mb-3 font-semibold text-purple-600 sm:mb-4"
																style={{
																	fontSize:
																		"clamp(16px, 4vw, 18px)",
																}}
															>
																{section.title}
															</h4>
															<div className="grid grid-cols-1 gap-3 sm:gap-4 lg:grid-cols-2">
																{/* Male Communication Style */}
																<div
																	className="border border-blue-200"
																	style={{
																		padding:
																			"clamp(12px, 3vw, 16px)",
																		borderRadius:
																			"clamp(8px, 2vw, 12px)",
																	}}
																>
																	<div className="flex items-center mb-2">
																		<div
																			className="mr-2 bg-blue-500 rounded-full"
																			style={{
																				width: "clamp(10px, 2.5vw, 12px)",
																				height: "clamp(10px, 2.5vw, 12px)",
																			}}
																		></div>
																		<span
																			className="font-medium text-blue-700"
																			style={{
																				fontSize:
																					"clamp(13px, 3.2vw, 15px)",
																			}}
																		>
																			ç”·æ–¹æºé€šé¢¨æ ¼
																		</span>
																	</div>
																	<p
																		className="leading-relaxed text-gray-700"
																		style={{
																			fontSize:
																				"clamp(12px, 3vw, 14px)",
																		}}
																	>
																		{
																			section.maleStyle
																		}
																	</p>
																</div>
																{/* Female Communication Style */}
																<div
																	className="border border-pink-200"
																	style={{
																		padding:
																			"clamp(12px, 3vw, 16px)",
																		borderRadius:
																			"clamp(8px, 2vw, 12px)",
																	}}
																>
																	<div className="flex items-center mb-2">
																		<div
																			className="mr-2 bg-pink-500 rounded-full"
																			style={{
																				width: "clamp(10px, 2.5vw, 12px)",
																				height: "clamp(10px, 2.5vw, 12px)",
																			}}
																		></div>
																		<span
																			className="font-medium text-pink-700"
																			style={{
																				fontSize:
																					"clamp(13px, 3.2vw, 15px)",
																			}}
																		>
																			å¥³æ–¹æºé€šé¢¨æ ¼
																		</span>
																	</div>
																	<p
																		className="leading-relaxed text-gray-700"
																		style={{
																			fontSize:
																				"clamp(12px, 3vw, 14px)",
																		}}
																	>
																		{
																			section.femaleStyle
																		}
																	</p>
																</div>
															</div>
														</div>
													) : section.type ===
													  "practical-application" ? (
														/* Practical Application Section with Male/Female Strategies */
														<div className="space-y-3 sm:space-y-4">
															<h4
																className="mb-3 font-semibold text-purple-600 sm:mb-4"
																style={{
																	fontSize:
																		"clamp(16px, 4vw, 18px)",
																}}
															>
																{section.title}
															</h4>
															{/* Each conflict type with side-by-side strategies */}
															{section.subsections.map(
																(
																	subsection,
																	subIndex
																) => (
																	<div
																		key={
																			subIndex
																		}
																		className="space-y-2 sm:space-y-3"
																	>
																		{/* Conflict Type Title */}
																		<div
																			className="font-medium text-center text-white bg-green-500"
																			style={{
																				padding:
																					"clamp(6px, 1.5vw, 8px) clamp(8px, 2vw, 12px)",
																				fontSize:
																					"clamp(12px, 3vw, 14px)",
																				borderRadius:
																					"clamp(6px, 1.5vw, 8px)",
																			}}
																		>
																			{
																				subsection.title
																			}
																		</div>
																		{/* Male and Female Strategies Side by Side */}
																		<div className="grid grid-cols-1 gap-3 sm:gap-4 lg:grid-cols-2">
																			{/* Male Strategy */}
																			<div
																				className="border border-blue-200 bg-blue-50"
																				style={{
																					padding:
																						"clamp(12px, 3vw, 16px)",
																					borderRadius:
																						"clamp(8px, 2vw, 12px)",
																				}}
																			>
																				<div className="flex items-center mb-2">
																					<div
																						className="mr-2 bg-blue-500 rounded-full"
																						style={{
																							width: "clamp(10px, 2.5vw, 12px)",
																							height: "clamp(10px, 2.5vw, 12px)",
																						}}
																					></div>
																					<span
																						className="font-medium text-blue-700"
																						style={{
																							fontSize:
																								"clamp(12px, 3vw, 14px)",
																						}}
																					>
																						ç”·æ–¹æºé€šç­–ç•¥
																					</span>
																				</div>
																				<div
																					className="text-gray-700 bg-gray-100"
																					style={{
																						padding:
																							"clamp(8px, 2vw, 12px)",
																						fontSize:
																							"clamp(11px, 2.8vw, 13px)",
																						lineHeight:
																							"1.5",
																						borderRadius:
																							"clamp(6px, 1.5vw, 8px)",
																					}}
																				>
																					{
																						subsection.maleStrategy
																					}
																				</div>
																			</div>
																			{/* Female Strategy */}
																			<div
																				className="border border-pink-200 bg-pink-50"
																				style={{
																					padding:
																						"clamp(12px, 3vw, 16px)",
																					borderRadius:
																						"clamp(8px, 2vw, 12px)",
																				}}
																			>
																				<div className="flex items-center mb-2">
																					<div
																						className="mr-2 bg-pink-500 rounded-full"
																						style={{
																							width: "clamp(10px, 2.5vw, 12px)",
																							height: "clamp(10px, 2.5vw, 12px)",
																						}}
																					></div>
																					<span
																						className="font-medium text-pink-700"
																						style={{
																							fontSize:
																								"clamp(12px, 3vw, 14px)",
																						}}
																					>
																						å¥³æ–¹æºé€šç­–ç•¥
																					</span>
																				</div>
																				<div
																					className="text-gray-700 bg-gray-100"
																					style={{
																						padding:
																							"clamp(8px, 2vw, 12px)",
																						fontSize:
																							"clamp(11px, 2.8vw, 13px)",
																						lineHeight:
																							"1.5",
																						borderRadius:
																							"clamp(6px, 1.5vw, 8px)",
																					}}
																				>
																					{
																						subsection.femaleStrategy
																					}
																				</div>
																			</div>
																		</div>
																	</div>
																)
															)}
															{/* Additional Info */}
															{section.timing && (
																<div
																	className="mt-3 sm:mt-4 bg-purple-50"
																	style={{
																		padding:
																			"clamp(8px, 2vw, 12px)",
																		borderRadius:
																			"clamp(6px, 1.5vw, 8px)",
																	}}
																>
																	<span
																		className="font-medium text-purple-700"
																		style={{
																			fontSize:
																				"clamp(12px, 3vw, 14px)",
																		}}
																	>
																		æœ€ä½³æ™‚æ©Ÿï¼š
																	</span>
																	<span
																		className="text-gray-700"
																		style={{
																			fontSize:
																				"clamp(12px, 3vw, 14px)",
																		}}
																	>
																		{
																			section.timing
																		}
																	</span>
																</div>
															)}
														</div>
													) : null}
												</div>
											)
										)}
									</div>
								) : typeof activeCategory.content ===
										"object" &&
								  activeCategory.content.type ===
										"relationship-taboos" ? (
									/* Relationship Taboos Structure */
									<div className="space-y-4 sm:space-y-6">
										{/* Main Taboo Sections */}
										{activeCategory.content.sections.map(
											(section, sectionIndex) => (
												<div
													key={sectionIndex}
													className="space-y-3 sm:space-y-4"
												>
													{/* Section Header */}
													<div
														className={`${section.color} text-white font-bold text-center`}
														style={{
															padding:
																"clamp(8px, 2vw, 12px) clamp(12px, 3vw, 16px)",
															fontSize:
																"clamp(14px, 3.5vw, 16px)",
															borderRadius:
																"clamp(8px, 2vw, 12px)",
														}}
													>
														{section.title}
													</div>

													{/* Subsections Grid */}
													<div className="grid grid-cols-1 gap-3 sm:gap-4 sm:grid-cols-2 lg:grid-cols-3">
														{section.subsections.map(
															(
																subsection,
																subIndex
															) => (
																<div
																	key={
																		subIndex
																	}
																	className="overflow-hidden border-2 border-gray-200"
																	style={{
																		borderRadius:
																			"clamp(8px, 2vw, 12px)",
																	}}
																>
																	{/* Subsection Header */}
																	<div
																		className={`${
																			sectionIndex ===
																			0
																				? "bg-pink-500"
																				: sectionIndex ===
																					  1
																					? "bg-green-500"
																					: "bg-red-700"
																		} text-white font-medium text-center`}
																		style={{
																			padding:
																				"clamp(6px, 1.5vw, 8px) clamp(8px, 2vw, 12px)",
																			fontSize:
																				"clamp(12px, 3vw, 14px)",
																		}}
																	>
																		{
																			subsection.title
																		}
																	</div>
																	{/* Subsection Content */}
																	<div
																		className="bg-gray-50"
																		style={{
																			padding:
																				"clamp(12px, 3vw, 16px)",
																		}}
																	>
																		<p
																			className="leading-relaxed text-gray-700"
																			style={{
																				fontSize:
																					"clamp(11px, 2.8vw, 13px)",
																			}}
																		>
																			{
																				subsection.content
																			}
																		</p>
																	</div>
																</div>
															)
														)}
													</div>
												</div>
											)
										)}

										{/* Monthly Note Section */}
										{/* {activeCategory.content.monthlyNote && (
											<div className="p-4 mt-6 border-2 border-yellow-300 rounded-lg bg-yellow-50">
												<h4 className="mb-2 font-medium text-yellow-700">
													{
														activeCategory.content
															.monthlyNote.title
													}
												</h4>
												<p className="text-sm leading-relaxed text-gray-700">
													{
														activeCategory.content
															.monthlyNote.content
													}
												</p>
											</div>
										)} */}
									</div>
								) : typeof activeCategory.content ===
										"object" &&
								  activeCategory.content.type ===
										"energy-enhancement" ? (
									/* Energy Enhancement Structure */
									<div className="space-y-4 sm:space-y-6">
										{/* Energy Analysis (if available) */}
										{activeCategory.content.analysis && (
											<div
												className="mb-4 bg-green-100 border border-green-300 sm:mb-6"
												style={{
													padding:
														"clamp(12px, 3vw, 16px)",
													borderRadius:
														"clamp(8px, 2vw, 12px)",
												}}
											>
												<h4
													className="mb-2 font-medium text-green-700"
													style={{
														fontSize:
															"clamp(14px, 3.5vw, 16px)",
													}}
												>
													äº”è¡Œèƒ½é‡åˆ†æž
												</h4>
												<p
													className="text-gray-700"
													style={{
														fontSize:
															"clamp(12px, 3vw, 14px)",
													}}
												>
													{
														activeCategory.content
															.analysis
													}
												</p>
											</div>
										)}

										{/* Male and Female Enhancement Sections */}
										<div className="grid grid-cols-1 gap-4 sm:gap-6 lg:grid-cols-2">
											{/* Male Enhancement Section */}
											<div
												className="overflow-hidden border-2 border-blue-300"
												style={{
													borderRadius:
														"clamp(8px, 2vw, 12px)",
												}}
											>
												{/* Male Header */}
												<div
													className="font-medium text-center text-white bg-blue-500"
													style={{
														padding:
															"clamp(6px, 1.5vw, 8px) clamp(12px, 3vw, 16px)",
														fontSize:
															"clamp(14px, 3.5vw, 16px)",
													}}
												>
													{
														activeCategory.content
															.maleSection.title
													}
												</div>

												{/* Male Action Advice */}
												<div
													className="space-y-2 sm:space-y-3"
													style={{
														padding:
															"clamp(12px, 3vw, 16px)",
													}}
												>
													<div
														className="bg-blue-100"
														style={{
															padding:
																"clamp(8px, 2vw, 12px)",
															borderRadius:
																"clamp(6px, 1.5vw, 8px)",
														}}
													>
														<h5
															className="mb-2 font-medium text-blue-700"
															style={{
																fontSize:
																	"clamp(13px, 3.2vw, 15px)",
															}}
														>
															è¡Œå‹•å»ºè­°
														</h5>
														{activeCategory.content.maleSection.actionAdvice.map(
															(advice, index) => (
																<p
																	key={index}
																	className="mb-2 text-gray-700"
																	style={{
																		fontSize:
																			"clamp(11px, 2.8vw, 13px)",
																	}}
																>
																	â€¢ {advice}
																</p>
															)
														)}
													</div>

													{/* Male Accessories */}
													<div
														className="bg-blue-50"
														style={{
															padding:
																"clamp(8px, 2vw, 12px)",
															borderRadius:
																"clamp(6px, 1.5vw, 8px)",
														}}
													>
														<h5
															className="mb-2 font-medium text-blue-700"
															style={{
																fontSize:
																	"clamp(13px, 3.2vw, 15px)",
															}}
														>
															é–‹é‹ç‰©
														</h5>
														<p
															className="text-gray-700"
															style={{
																fontSize:
																	"clamp(11px, 2.8vw, 13px)",
															}}
														>
															{
																activeCategory
																	.content
																	.maleSection
																	.accessories
															}
														</p>
													</div>
												</div>
											</div>

											{/* Female Enhancement Section */}
											<div
												className="overflow-hidden border-2 border-pink-300"
												style={{
													borderRadius:
														"clamp(8px, 2vw, 12px)",
												}}
											>
												{/* Female Header */}
												<div
													className="font-medium text-center text-white bg-pink-500"
													style={{
														padding:
															"clamp(6px, 1.5vw, 8px) clamp(12px, 3vw, 16px)",
														fontSize:
															"clamp(14px, 3.5vw, 16px)",
													}}
												>
													{
														activeCategory.content
															.femaleSection.title
													}
												</div>

												{/* Female Action Advice */}
												<div
													className="space-y-2 sm:space-y-3"
													style={{
														padding:
															"clamp(12px, 3vw, 16px)",
													}}
												>
													<div
														className="bg-pink-100"
														style={{
															padding:
																"clamp(8px, 2vw, 12px)",
															borderRadius:
																"clamp(6px, 1.5vw, 8px)",
														}}
													>
														<h5
															className="mb-2 font-medium text-pink-700"
															style={{
																fontSize:
																	"clamp(13px, 3.2vw, 15px)",
															}}
														>
															è¡Œå‹•å»ºè­°
														</h5>
														{activeCategory.content.femaleSection.actionAdvice.map(
															(advice, index) => (
																<p
																	key={index}
																	className="mb-2 text-gray-700"
																	style={{
																		fontSize:
																			"clamp(11px, 2.8vw, 13px)",
																	}}
																>
																	â€¢ {advice}
																</p>
															)
														)}
													</div>

													{/* Female Accessories */}
													<div
														className="bg-pink-50"
														style={{
															padding:
																"clamp(8px, 2vw, 12px)",
															borderRadius:
																"clamp(6px, 1.5vw, 8px)",
														}}
													>
														<h5
															className="mb-2 font-medium text-pink-700"
															style={{
																fontSize:
																	"clamp(13px, 3.2vw, 15px)",
															}}
														>
															é–‹é‹ç‰©
														</h5>
														<p
															className="text-gray-700"
															style={{
																fontSize:
																	"clamp(11px, 2.8vw, 13px)",
															}}
														>
															{
																activeCategory
																	.content
																	.femaleSection
																	.accessories
															}
														</p>
													</div>
												</div>
											</div>
										</div>

										{/* Feng Shui Suggestions (if available) */}
										{activeCategory.content
											.fengShuiSuggestions && (
											<div
												className="border border-yellow-300 bg-yellow-50"
												style={{
													padding:
														"clamp(12px, 3vw, 16px)",
													borderRadius:
														"clamp(8px, 2vw, 12px)",
												}}
											>
												<h4
													className="mb-2 font-medium text-yellow-700"
													style={{
														fontSize:
															"clamp(14px, 3.5vw, 16px)",
													}}
												>
													å±…å®¶é¢¨æ°´å»ºè­°
												</h4>
												{activeCategory.content.fengShuiSuggestions.map(
													(suggestion, index) => (
														<p
															key={index}
															className="mb-2 text-gray-700"
															style={{
																fontSize:
																	"clamp(11px, 2.8vw, 13px)",
															}}
														>
															â€¢ {suggestion}
														</p>
													)
												)}
											</div>
										)}

										{/* Lucky Colors (if available) */}
										{activeCategory.content.luckyColors && (
											<div
												className="border border-purple-300 bg-purple-50"
												style={{
													padding:
														"clamp(12px, 3vw, 16px)",
													borderRadius:
														"clamp(8px, 2vw, 12px)",
												}}
											>
												<h4
													className="mb-2 font-medium text-purple-700"
													style={{
														fontSize:
															"clamp(14px, 3.5vw, 16px)",
													}}
												>
													å¹´åº¦å¹¸é‹è‰²ç³»
												</h4>
												<p
													className="text-gray-700"
													style={{
														fontSize:
															"clamp(11px, 2.8vw, 13px)",
													}}
												>
													{
														activeCategory.content
															.luckyColors
													}
												</p>
											</div>
										)}

										{/* Shared Enhancement Section */}
										<div
											className="overflow-hidden border-2 border-green-300 bg-green-50"
											style={{
												borderRadius:
													"clamp(8px, 2vw, 12px)",
											}}
										>
											{/* Shared Enhancement Header */}
											<div
												className="font-medium text-center text-white bg-green-500"
												style={{
													padding:
														"clamp(6px, 1.5vw, 8px) clamp(12px, 3vw, 16px)",
													fontSize:
														"clamp(14px, 3.5vw, 16px)",
												}}
											>
												{
													activeCategory.content
														.sharedEnhancement.title
												}
											</div>

											<div
												className="space-y-3 sm:space-y-4"
												style={{
													padding:
														"clamp(12px, 3vw, 16px)",
												}}
											>
												{/* Weekly Ritual */}
												<div
													className="bg-white border border-green-200"
													style={{
														padding:
															"clamp(12px, 3vw, 16px)",
														borderRadius:
															"clamp(6px, 1.5vw, 8px)",
													}}
												>
													<h5
														className="mb-2 font-medium text-green-700"
														style={{
															fontSize:
																"clamp(13px, 3.2vw, 15px)",
														}}
													>
														{
															activeCategory
																.content
																.sharedEnhancement
																.weeklyRitual
																.title
														}
													</h5>
													<p
														className="text-gray-700"
														style={{
															fontSize:
																"clamp(11px, 2.8vw, 13px)",
														}}
													>
														{
															activeCategory
																.content
																.sharedEnhancement
																.weeklyRitual
																.content
														}
													</p>
												</div>

												{/* Situations Table */}
												{activeCategory.content
													.sharedEnhancement
													.situations &&
												activeCategory.content
													.sharedEnhancement
													.situations.length > 0 ? (
													<div
														className="overflow-hidden bg-white border border-green-200"
														style={{
															borderRadius:
																"clamp(6px, 1.5vw, 8px)",
														}}
													>
														{/* Table Header */}
														<div className="grid grid-cols-2 gap-1 font-medium text-gray-700 bg-green-100 sm:grid-cols-4">
															<div
																className="text-center border-r border-green-200"
																style={{
																	padding:
																		"clamp(6px, 1.5vw, 8px)",
																	fontSize:
																		"clamp(10px, 2.5vw, 12px)",
																}}
															>
																å ´åˆ
															</div>
															<div
																className="text-center border-r border-green-200"
																style={{
																	padding:
																		"clamp(6px, 1.5vw, 8px)",
																	fontSize:
																		"clamp(10px, 2.5vw, 12px)",
																}}
															>
																ç”·æ–¹ä¸»è‰²
															</div>
															<div
																className="text-center border-r border-green-200"
																style={{
																	padding:
																		"clamp(6px, 1.5vw, 8px)",
																	fontSize:
																		"clamp(10px, 2.5vw, 12px)",
																}}
															>
																å¥³æ–¹ä¸»è‰²
															</div>
															<div
																className="text-center"
																style={{
																	padding:
																		"clamp(6px, 1.5vw, 8px)",
																	fontSize:
																		"clamp(10px, 2.5vw, 12px)",
																}}
															>
																èƒ½é‡ä½œç”¨
															</div>
														</div>

														{/* Table Rows */}
														{activeCategory.content.sharedEnhancement.situations.map(
															(
																situation,
																index
															) => (
																<div
																	key={index}
																	className="grid grid-cols-4 text-sm border-b border-green-100 last:border-b-0"
																>
																	{/* Situation */}
																	<div className="p-2 font-medium text-center border-r border-green-200 bg-green-50">
																		{
																			situation.title
																		}
																	</div>

																	{/* Male Colors */}
																	<div className="p-2 text-center border-r border-green-200">
																		<div className="flex flex-wrap justify-center gap-1">
																			{situation.colors.male.map(
																				(
																					colorText,
																					colorIndex
																				) => {
																					// Extract color names from the full text
																					const colorMatches =
																						colorText.match(
																							/[æ·±æ·º][è—ç¶ é»ƒç´…ç™½é»‘ç°æ©™ç´«ç²‰æ£•ç±³å¡][\wè‰²]*/g
																						) ||
																							colorText.match(
																								/[è—ç¶ é»ƒç´…ç™½é»‘ç°æ©™ç´«ç²‰æ£•ç±³å¡][\wè‰²]*/g
																							) || [
																								"å¢¨ç¶ ",
																							];
																					return colorMatches.map(
																						(
																							colorName,
																							nameIndex
																						) => (
																							<div
																								key={`${colorIndex}-${nameIndex}`}
																								className="flex items-center mb-1 space-x-1"
																							>
																								<div
																									className={`w-3 h-3 rounded-full ${
																										colorName.includes(
																											"è—"
																										) ||
																										colorName.includes(
																											"æ·±è—"
																										)
																											? "bg-blue-600"
																											: colorName.includes(
																														"ç¶ "
																												  ) ||
																												  colorName.includes(
																														"æ·ºç¶ "
																												  ) ||
																												  colorName.includes(
																														"å¡å…¶"
																												  )
																												? "bg-green-500"
																												: colorName.includes(
																															"ç°"
																													  ) ||
																													  colorName.includes(
																															"æ·±ç°"
																													  )
																													? "bg-gray-500"
																													: colorName.includes(
																																"æ©™"
																														  ) ||
																														  colorName.includes(
																																"æ©™ç´…"
																														  )
																														? "bg-orange-500"
																														: colorName.includes(
																																	"æ£•"
																															  )
																															? "bg-orange-800"
																															: "bg-green-600"
																									}`}
																								></div>
																								<span className="text-xs">
																									{
																										colorName
																									}
																								</span>
																							</div>
																						)
																					);
																				}
																			)}
																		</div>
																	</div>

																	{/* Female Colors */}
																	<div className="p-2 text-center border-r border-green-200">
																		<div className="flex flex-wrap justify-center gap-1">
																			{situation.colors.female.map(
																				(
																					colorText,
																					colorIndex
																				) => {
																					// Extract color names from the full text
																					const colorMatches =
																						colorText.match(
																							/[æ·±æ·º][è—ç¶ é»ƒç´…ç™½é»‘ç°æ©™ç´«ç²‰æ£•ç±³][\wè‰²]*/g
																						) ||
																							colorText.match(
																								/[è—ç¶ é»ƒç´…ç™½é»‘ç°æ©™ç´«ç²‰æ£•ç±³æ·¡][\wè‰²]*/g
																							) || [
																								"å†°è—",
																							];
																					return colorMatches.map(
																						(
																							colorName,
																							nameIndex
																						) => (
																							<div
																								key={`${colorIndex}-${nameIndex}`}
																								className="flex items-center mb-1 space-x-1"
																							>
																								<div
																									className={`w-3 h-3 rounded-full ${
																										colorName.includes(
																											"ç²‰"
																										) ||
																										colorName.includes(
																											"æ·ºç²‰"
																										)
																											? "bg-pink-300"
																											: colorName.includes(
																														"ç´«"
																												  ) ||
																												  colorName.includes(
																														"æ·¡ç´«"
																												  )
																												? "bg-purple-300"
																												: colorName.includes(
																															"è—"
																													  ) ||
																													  colorName.includes(
																															"å†°è—"
																													  )
																													? "bg-blue-200"
																													: colorName.includes(
																																"ç±³"
																														  ) ||
																														  colorName.includes(
																																"ç±³è‰²"
																														  )
																														? "bg-yellow-100"
																														: colorName.includes(
																																	"ç™½"
																															  ) ||
																															  colorName.includes(
																																	"éŠ€ç™½"
																															  )
																															? "bg-gray-100"
																															: colorName.includes(
																																		"é»ƒ"
																																  ) ||
																																  colorName.includes(
																																		"æ·¡é»ƒ"
																																  )
																																? "bg-yellow-200"
																																: "bg-pink-200"
																									}`}
																								></div>
																								<span className="text-xs">
																									{
																										colorName
																									}
																								</span>
																							</div>
																						)
																					);
																				}
																			)}
																		</div>
																	</div>

																	{/* Energy Function */}
																	<div className="p-2 text-center">
																		<span className="text-xs text-gray-600">
																			{
																				situation.energyFunction
																			}
																		</span>
																	</div>
																</div>
															)
														)}
													</div>
												) : (
													<div className="p-4 border border-orange-300 rounded-lg bg-orange-50">
														<h5 className="mb-2 font-medium text-orange-700">
															å ´åˆè‰²å½©æ­é…
														</h5>
														<p className="text-sm text-orange-600">
															ðŸ”„ AI
															å°šæœªç”Ÿæˆå ´åˆè‰²å½©æ­é…è¡¨æ ¼ã€‚é€™æ˜¯å› ç‚ºç•¶å‰çš„
															API
															è¼¸å‡ºä¸­ç¼ºå°‘çµæ§‹åŒ–çš„è‰²å½©å»ºè­°éƒ¨åˆ†ã€‚
														</p>
														<p className="mt-2 text-xs text-gray-500">
															è«‹é‡æ–°ç”Ÿæˆåˆ†æžä»¥ç²å–å®Œæ•´çš„è‰²å½©æ­é…å»ºè­°ã€‚
														</p>
													</div>
												)}
											</div>
										</div>
									</div>
								) : (
									/* Regular text content */
									<div
										className="leading-relaxed text-gray-700 whitespace-pre-line"
										style={{
											fontSize:
												"clamp(13px, 3.2vw, 16px)",
											lineHeight: "1.6",
										}}
									>
										{typeof activeCategory.content ===
											"object" &&
										activeCategory.content.type === "text"
											? activeCategory.content.content
											: activeCategory.content}
									</div>
								)}
							</div>
						</div>
					</div>
				</div>

				{/* Motto Section */}
				{/* <div className="p-6 mt-8 text-center bg-gradient-to-r from-pink-100 to-red-100 rounded-xl">
					<p className="text-lg font-medium text-gray-800">
						ðŸ’• {analysisData.motto}
					</p>
				</div> */}
			</section>
		</ComponentErrorBoundary>
	);
}
